                                        # Check numbers of individuals in various parts of the pipeline such that the numbers match those in the release sample QC file.
                                        # This is for the paper!
h = c("/well/ukbiobank/expt/V2_QCed.SNP-QC/src/V2_QCed.snpqc-tests.R","/well/ukbiobank/expt/V2_QCed.SNP-QC/src/V2_QCed.bin2clusterplots.R","/well/ukbiobank/qcoutput.V2_QCed.sample-QC/QC-Scripts/R/scripts/readPSperformance.R","/well/ukbiobank/qcoutput.V2_QCed.sample-QC/QC-Scripts/R/scripts/auxFunctions.R")
for(s in h) source(s)
source("/well/ukbiobank/qcoutput.V2_QCed.sample-QC/QC-Scripts/R/scripts/ukbbcolors.R")

library(igraph)
library(xtable)
library(hexbin)
library(latticeExtra)
library(viridis)


setwd('/well/ukbiobank/qcoutput.V2_QCed.sample-QC/QC-Scripts/forPaper')


# Main sample QC file for release (generated by $basedir/QC-Scripts/Sample-QC/Flags/create-sample-table.R)
###########
releaseSampleQCPrefix = 'b1__b11-b001__b095-sampleTable_v4'
###########


load(paste0('../../data/ForRelease/',releaseSampleQCPrefix,'_allColumns.RData'),verbose=TRUE)

# Duplicates file (Clare excluded samples not based on this file, but based on the list that were found in the genotype data used for release. But this file can explain some of the exclusions.)
dupes = read.table('/well/ukbiobank/expt/V2_QCed.identical_samples/data/V2_QCed.duplicates_exclude.txt',stringsAsFactors=FALSE)[,1]

# Genotypes for release (v2 bim only differs in some X chrom snps)
GenotypesForReleaseBim = read.table('/well/ukbiobank/expt/V2_QCed.export/data/calls_export/v2/V2_QCed.export.UKBiLEVEAX_b1-b11.Batch_b001_b095.bim',stringsAsFactors=FALSE,header=FALSE)

GenotypesForReleaseFiles = '/well/ukbiobank/expt/V2_QCed.export/data/calls_export/v3/V2_QCed.export.UKBiLEVEAX_b1-b11.Batch_b001_b095'

# SNP annotations (all snps, not just those successfully typed)
BB.ps2snp = ukbiobank.ps2snp("autosome")
BL.ps2snp = ukbileve.ps2snp("autosome")
ps2snpBoth = unique(BL.ps2snp[BL.ps2snp$AffySNPID%in%BB.ps2snp$AffySNPID,])
ps2snpEither = unique(rbind(BL.ps2snp,BB.ps2snp))

# Raw sample tables (before Oxford QC)
#otherInfo = read.multiple.batch.info(batchInfoFields)

######################
# set some basic par() values
######################
par(bty="n") # remove border boxes from plots


#################################
# Total number of released individuals
#################################

nInds = dim(outTable)[1]
print( paste0( " All inds: ",nInds) )


#################################
# Table of batches and plates (after excluding duplicates and controls and non-working samples)
#################################

batches=all.batches()

batchTab = table(outTable$Batch)[batches]
nPlates = sapply(batches,function(b) {
    uPlates = unique(outTable$Plate.Name[outTable$Batch==b])
    if(sum(is.na(uPlates))!=0) print(sum(is.na(uPlates)))
    length(uPlates)
})
plateSizes = sapply(batches,function(b) {
    nPlates = table(outTable$Plate.Name[outTable$Batch==b])
})

medPlateSize = sapply(plateSizes,median)
meanPlateSize = sapply(plateSizes,mean)

# for the total line:
tSamples = sum(batchTab)
tPlates = length(unique(outTable$Plate.Name))
medPlatesize = median(table(outTable$Plate.Name))
meanPlatesize = mean(table(outTable$Plate.Name))

batchInfoTable = cbind(names(batchTab),as.data.frame(cbind(batchTab,nPlates,medPlateSize)))
colnames(batchInfoTable) = c("Batch","Batch size","Number of processed plates","Median plate size")

write.table(batchInfoTable,file=paste0(releaseSampleQCPrefix,"-BatchInfoTable.txt"),quote=FALSE,col.names=TRUE,row.names=FALSE,sep="\t")

xTab = xtable(batchInfoTable, caption = NULL, label = NULL, align = NULL, display = NULL)
digits(xTab) <- xdigits(xTab)
align(xTab) <- paste(c("|r|r|",rep("p{0.1\\textwidth}",dim(batchInfoTable)[2]-1),"|"),collapse="")
# this is long table covering multiple pages
add.to.row <- list(pos = list(0), command = NULL)
command <- paste0("\\hline\n\\endhead\n",
"\\hline\n",
"\\multicolumn{", dim(xTab)[2], "}{l}",
"{\\footnotesize Continued on next page}\n",
"\\endfoot\n",
"\\endlastfoot\n")
add.to.row$command <- command

sink(file=paste0(releaseSampleQCPrefix,"-BatchInfoTable.tex"))
print(xTab,size="footnotesize",hline.after=c(-1), add.to.row = add.to.row,
tabular.environment = "longtable",include.rownames = FALSE,sanitize.colnames.function = bold)
sink()

# Original batch sizes (excluding reference controls)
origSampleTable = read.multiple.batch.info(batchInfoFields)
origBatchSizes = table(origSampleTable$Batch)

nIndsOrig = table(origSampleTable$UKB)
nIndsOrigUKBB = sum(origSampleTable$Batch%in%ukbiobank.batches())
nIndsOrigUKBL = sum(origSampleTable$Batch%in%ukbileve.batches())

#length(unique(origSampleTable$PIID))


#################################
# Sex chrom phasing exclusions
#################################

load('../Sample-QC/sexChroms/b1__b11-b001__b095-sexchrom-sampleqc-sexCheck-phaseExclusionsCriteria1.Rdata',verbose=TRUE)

print(" Counts in QC pipeline data: ")
print( paste0("x0 : ",length(x0)) )
print( paste0("xxx : ",length(xxx)) )
print( paste0("xxy : ",length(xxy)) )
print( paste0("yy : ",length(yyy)) )
print( paste0("all : ",length(allPhaseExclusionsX)) )

# 2 individuals are in yyy and xxyy! Just count them as yyy
xxy = xxy[!xxy%in%yyy]
print(" Intersection with output individuals: ")
print( paste0("x0 : ",length(intersect(x0,outTable$PIID)) ) )
print( paste0("xxx : ",length(intersect(xxx,outTable$PIID)) ) )
print( paste0("xxy : ",length(intersect(xxy,outTable$PIID)) ) )
print( paste0("yy : ",length(intersect(yyy,outTable$PIID)) ) )
print( paste0("all : ",length(intersect(allPhaseExclusionsX,outTable$PIID)) ) )

                                        # NOTE: all the excluded samples are in the duplicates file.
# make a table of sex mismatches vs different kinds of aneuploidies
anuInds = rep(0,nInds);
anuInds[outTable$PIID%in%x0]="x0"
anuInds[outTable$PIID%in%xxx]="xxx"
anuInds[outTable$PIID%in%xxy]="xxy"
anuInds[outTable$PIID%in%yyy]="yy"

print( table(anuInds) )
print( sum( table(anuInds)[-1]) )


sexMismatches = rep(0,nInds);
sexMismatches[outTable$Submitted.Gender!=outTable$Inferred.Gender]=1

crossTab = table(sexMismatches,anuInds)
print(crossTab)

sexTab = t(rbind(crossTab,colSums(crossTab)))
sexTab = sexTab[c("x0","xxx","xxy","yy","0"),]
sexTab = rbind(sexTab,colSums(sexTab))
sexTab = cbind(c("Inferred female and L2Rx < -0.17","Inferred female and L2Rx > 0.145","-1 >= L2Ry < 0.23 and L2Rx > -0.2","L2Ry >= 0.23","Not any of the above",""),
    c("X0 (complete, or mosaic)","XXX","XXY","XXYY or YY","XX or XY","Total"),
    sexTab,
    round(10000*sexTab[,3]/nInds,1))
colnames(sexTab) = c("Criteria","Putative sex chromosome karyotype","Sex match","Sex mismatch","Total","Rate per 10,000")

print(sexTab)

# print as latex table and text table
write.table(sexTab,file=paste0(releaseSampleQCPrefix,"-SexAneuploidyTable.txt"),quote=FALSE,col.names=TRUE,row.names=FALSE)

xTab = xtable(sexTab, caption = NULL, label = NULL, align = NULL, display = NULL)
digits(xTab) <- xdigits(xTab)
add.to.row <- list(pos = list(-1), command = NULL)
command <- paste0("\\rowstyle{\\setstretch{1}\\bfseries\\cellcolor[gray]{0}}")
add.to.row$command <- command

sink(file=paste0(releaseSampleQCPrefix,"-SexAneuploidyTable.tex"))
print(xTab,size="small",include.rownames = FALSE,add.to.row=add.to.row,sanitize.colnames.function = white)
sink()
# ===> some further edits made by hand


#############
# Fractions

nF = table(outTable$Submitted.Gender)["F"]
nM = table(outTable$Submitted.Gender)["M"]

p = length(x0)/nF
se = sqrt ( p*(1 - p) / nF )
X0Est = paste0("X0: ",round(p*10000,3)," (SE ",round(10000*se,3),")")

p = length(xxx)/nF
se = sqrt ( p*(1 - p) / nF )
XXXEst = paste0("XXX: ",round(p*10000,3)," (SE ",round(10000*se,3),")")

p = length(xxy)/nM
se = sqrt ( p*(1 - p) / nM )
XXYEst = paste0("XXY: ",round(p*10000,3)," (SE ",round(10000*se,3),")")

p = (length(yyy)-2)/nM
se = sqrt ( p*(1 - p) / nM )
XYYEst = paste0("XYY: ",round(p*10000,3)," (SE ",round(10000*se,3),")")

p = 2/nM
se = sqrt ( p*(1 - p) / nM )
XXYYEst = paste0("XXYY: ",round(p*10000,3)," (SE ",round(10000*se,3),")")

print(c(X0Est,XXXEst,XXYEst,XYYEst,XXYYEst))



####### Plot the computed L2R, with the exclusions

# get data from cnv summaries ==> ExtractCNV/compute-cnv-summaries.R
load(paste0(baseSampleQCDir,"/data/CNV/b1__b11-b001__b095-sexchrom-sampleqc-cnv-summaries.RData"),verbose=TRUE)

l2rsum = outData[["log2ratio"]][outTable$PIID,]
X = l2rsum[,"means.X"]
Y = l2rsum[,"means.Y"]
Ynorm = Y - X
excl = outTable$PIID%in%allPhaseExclusionsX

shapesEx = rep(1,length(X))
shapesEx[excl] = 4 # exclusions


#sexCols=getColBlindCol(c("r","g","v","b"))
#sexCols = c("purple","darkgreen","blue","red")
#names(sexCols) = c("M","F","MtoF","FtoM")

colorsEx = rep(sexCols["M"],length(X)) # males
colorsEx[outTable$Submitted.Gender=="F"] = sexCols["F"] # females
colorsEx[(outTable$Submitted.Gender=="M")&(sexMismatches==1)] = sexCols["MtoF"] # sex mismatches male self-reported
colorsEx[(outTable$Submitted.Gender=="F")&(sexMismatches==1)] = sexCols["FtoM"] # sex mismatches female self-reported
#colorsEx[!excl] = add.alpha(colorsEx[!excl],0.5)

# Putative aneuploidies don't include any of the het.miss.outliers, even if they fit the criteria, so remove them from the plot!
#colorsEx[outTable$het.missing.outliers==1]=NA
#shapes[outTable$het.missing.outliers==1]=NA

Order = order.by.number.occurrences(paste0(shapesEx,"_",colorsEx))

t = Order[Order%in%which(excl)]

Order = Order[!Order%in%which(outTable$het.missing.outliers==1)]

x = X; y = Y

#Order = sample(Order,100,replace=FALSE)
malesOrdinary = outTable$PIID[outTable$Submitted.Gender=="M"]
malesOrdinary = malesOrdinary[!malesOrdinary%in%intersect(allPhaseExclusionsX,outTable$PIID)]
femalesOrdinary = outTable$PIID[outTable$Submitted.Gender=="F"]
femalesOrdinary = femalesOrdinary[!femalesOrdinary%in%intersect(allPhaseExclusionsX,outTable$PIID)]

meanXforXX = mean(x[rownames(l2rsum)%in%femalesOrdinary])
meanXforXY = mean(x[rownames(l2rsum)%in%malesOrdinary])
meanYforXX = mean(y[rownames(l2rsum)%in%femalesOrdinary])
meanYforXY = mean(y[rownames(l2rsum)%in%malesOrdinary])


#Order=sample(Order,1000,replace=FALSE)

png( paste0("plots/",releaseSampleQCPrefix,"-L2Rmean-exclusions-mismatches2.png"),bg="transparent",height=2*3*1500,width=2*3*1500,res=2*450) #width=2*3*1500,height=2*3*1500,res=2*450)
#pdf( paste0("plots/",releaseSampleQCPrefix,"-L2Rmean-exclusions-mismatches.pdf"),bg="transparent",width=3*1500/450,height=3*1500/450)
par(cex.lab=1.5,mar=c(5.1,5.1,3,2),cex.main=1.5,cex.axis=1.2)

plot(x[Order],y[Order],col=colorsEx[Order],pch=shapesEx[Order],xlab="mean L2R sex-specific X chromosome",ylab="mean L2R Y chromosome",main="Sex mismatches and putative sex chromosome aneuploidy")
#abline(v = c(-0.17,0.15,-0.2),lty=3)
#abline(h = c(-1,0.23),lty=3)

#text(c(meanXforXY,meanXforXX,meanXforXY),c(-meanXforXY,meanYforXY,meanYforXX),labels=c(expression(pi),expression(alpha),expression(gamma)))

dev.off()

png( paste0("plots/",releaseSampleQCPrefix,"-L2Rmean-exclusions-mismatches3.png"),bg="transparent",height=3*1500,width=3*1500,res=450) #width=2*3*1500,height=2*3*1500,res=2*450)
#pdf( paste0("plots/",releaseSampleQCPrefix,"-L2Rmean-exclusions-mismatches.pdf"),bg="transparent",width=3*1500/450,height=3*1500/450)
par(cex.lab=1.5,mar=c(5.1,5.1,3,2),cex.main=1.5,cex.axis=1.2)

plot(x[Order],y[Order],col=add.alpha(colorsEx[Order],0.5),pch=shapesEx[Order],xlab="mean L2R sex-specific X chromosome",ylab="mean L2R Y chromosome",main="Sex mismatches and putative sex chromosome aneuploidy")
#abline(v = c(-0.17,0.15,-0.2),lty=3)
#abline(h = c(-1,0.23),lty=3)
points(x[t],y[t],col=colorsEx[t],pch=shapesEx[t])
#text(c(meanXforXY,meanXforXX,meanXforXY),c(-meanXforXY,meanYforXY,meanYforXX),labels=c(expression(pi),expression(alpha),expression(gamma)))

dev.off()




# plot LEGEND
#png(paste0("plots/",releaseSampleQCPrefix,"-L2Rmean-exclusions-mismatches-LEGEND.png"),bg="transparent",width=1000,height=1000,res=150)
pdf(paste0("plots/",releaseSampleQCPrefix,"-L2Rmean-exclusions-mismatches-LEGEND.pdf"),bg="transparent",width=1000/150,height=800/150)
par(cex=1)
plot(NULL,xlim=c(0,1),ylim=c(0,1),axes=FALSE,xlab=NA,ylab=NA)

legend('topleft',c(" Self-reported male, inferred male"," Self-reported female, inferred female"," Self-reported male, inferred female"," Self-reported female, inferred male"),col=c(sexCols),title.adj = 0, cex=1.5,bty="n",pch="-",xpd=NA,title="Colour key",pt.cex=4)

legend('bottomleft',c("XX or XY karyotype","Putative aneuploidy"),title.adj = 0, pch=c(1,4),col="black",cex=1.5,bty="n",xpd=NA,title="Shape key",pt.lwd=3,pt.cex=1.8)

dev.off()

pdf(paste0("plots/",releaseSampleQCPrefix,"-L2Rmean-exclusions-mismatches-LEGEND2.pdf"),bg="transparent",width=1300/150,height=1000/150)
par(cex=1)
plot(NULL,xlim=c(0,1),ylim=c(0,1),axes=FALSE,xlab=NA,ylab=NA)

legend('topleft',c("Self-reported male, inferred male, XX or XY karyotype","Self-reported female, inferred female, XX or XY karyotype","Self-reported male, inferred female, XX or XY karyotype","Self-reported female, inferred male, XX or XY karyotype","",c("Self-reported male, inferred male, likely aneuploidy","Self-reported female, inferred female, Likely aneuploidy","Self-reported male, inferred female, likely aneuploidy","Self-reported female, inferred male, likely aneuploidy")),col=c(sexCols,NA,sexCols),title.adj = 0, cex=1.5,bty="n",xpd=NA,pch=c(rep(1,4),NA,rep(4,4)),pt.lwd=3,pt.cex=1.8)

dev.off()


###############
# Y l2r by age! <=== for Clare's thesis.

maleInds = (outTable$Inferred.Gender=="M")&(outTable$Submitted.Gender=="M")
x = outTable$Age.when.attended.assessment.centre[maleInds]

Ynorm = l2rsum[outTable$PIID[maleInds],"means.Y"]-l2rsum[maleInds,"means.X"]
Y = l2rsum[outTable$PIID[maleInds],"means.Y"]

meansPerAge = sapply(min(x,na.rm=TRUE):max(x,na.rm=TRUE),function(i) mean(Y[x==i],na.rm=TRUE))
medianPerAge = sapply(min(x,na.rm=TRUE):max(x,na.rm=TRUE),function(i) median(Y[x==i],na.rm=TRUE))


linearModel = lm(Y~x+I(x^2)+I(x^3))
toPred = data.frame(seq(min(x,na.rm=TRUE),max(x,na.rm=TRUE),by=0.5)); colnames(toPred) = "x"
pred = predict(linearModel,newdata = toPred)
                   
png(paste0("plots/",releaseSampleQCPrefix,"-L2Rmean-Y-byAge.png"),bg="transparent",width=2000,height=1500,res=250)

plot(x,Y,xlab="Age",ylab="mean L2R Y chromosome",pch=16,col=add.alpha("black",0.2))
#points(min(x,na.rm=TRUE):max(x,na.rm=TRUE),meansPerAge,xlab="Age",ylab="mean L2R Y chromosome",pch=18,col="blue",cex=0.8)
#points(min(x,na.rm=TRUE):max(x,na.rm=TRUE),medianPerAge,xlab="Age",ylab="mean L2R Y chromosome",pch=18,col="red",cex=0.8)
                   lines(toPred[,1],pred,col="red")
                   #legend("top",horiz=TRUE,lty=1,col="red",legend=paste0("Fit of data to cubic polynomial in age\np-value < 2.2e-16"),bty="n",inset=c(0,-0.14),xpd=NA,cex=0.8)

dev.off()


linearModel = lm(Ynorm~x+I(x^2)+I(x^3))
summary(linearModel)
toPred = data.frame(seq(min(x,na.rm=TRUE),max(x,na.rm=TRUE),by=0.5)); colnames(toPred) = "x"
pred = predict(linearModel,newdata = toPred)
                   
png(paste0("plots/",releaseSampleQCPrefix,"-L2Rmean-YnormedByX-byAge.png"),bg="transparent",width=2000,height=1500,res=250)

plot(x,Ynorm,xlab="Age",ylab="mean L2R Y/X",pch=16,col=add.alpha("black",0.2))
#points(min(x,na.rm=TRUE):max(x,na.rm=TRUE),meansPerAge,xlab="Age",ylab="mean L2R Y chromosome",pch=18,col="blue",cex=0.8)
#points(min(x,na.rm=TRUE):max(x,na.rm=TRUE),medianPerAge,xlab="Age",ylab="mean L2R Y chromosome",pch=18,col="red",cex=0.8)
                   lines(toPred[,1],pred,col="red")
                   legend("top",horiz=TRUE,lty=1,col="red",legend=paste0("Fit of data to cubic polynomial in age\np-value < 2.2e-16"),bty="n",inset=c(0,-0.14),xpd=NA,cex=0.8)

dev.off()






#################################
# Related individuals
#################################


#kin2 = read.table(paste0('../../data/ForRelease/',releaseSampleQCPrefix,'_Kinship.txt'),header=TRUE,stringsAsFactors=FALSE)
kin2 = outKin
kin.classes = get.kin.classes(kin2,0.0012)
kin2$class = kin.classes

print( table(kin.classes) )
print(  sum(outTable$in.kinship.table) )
relTab = c(table(kin.classes)[kinshipLegendOrder],sum(table(kin.classes)))
names(relTab)[-6] = kinNames[names(relTab)][-6]
names(relTab)[6]= "Total"

# write the total number of pairs as a text file and latex file
write.table(t(relTab),file=paste0(releaseSampleQCPrefix,"-NumberofRelatedPairsTable.txt"),quote=FALSE,col.names=TRUE,row.names=FALSE)

xTab = xtable(as.data.frame(t(relTab)), caption = NULL, label = NULL, align = NULL, display = NULL)
digits(xTab) <- xdigits(xTab)
add.to.row <- list(pos = list(0), command = NULL)
command <- paste0("\\rowstyle{\\setstretch{1}\\bfseries\\cellcolor[gray]{0}}")
add.to.row$command <- command

sink(file=paste0(releaseSampleQCPrefix,"-NumberofRelatedPairsTable.tex"))
print(xTab,size="small",include.rownames = FALSE,add.to.row=add.to.row,sanitize.colnames.function = white)
sink()
# ===> some further edits made by hand


##### Read kinship table if we had not filtered the snps
rawKin = read.table('/well/ukbiobank/qcoutput.V2_QCed.sample-QC/data/Relatedness/b1__b11-b001__b095-pair_batches-init-hetmiss-out.kin0',header=TRUE)
# exclude the individuals that were excluded in the filtered version, and not in the outTable.
excessRels = outTable$PIID[outTable$excluded.from.kinship==1]
toKeep = ( ( (!rawKin$ID1%in%excessRels)&(!rawKin$ID2%in%excessRels) ) & ( (rawKin$ID1%in%outTable$PIID)&(rawKin$ID2%in%outTable$PIID) ) )
rawKin2 = rawKin[toKeep,]

kin.classes.raw = get.kin.classes(rawKin2,0.002)
rawKin2$class = kin.classes.raw

print( paste0(length(unique(c(rawKin2$ID1,rawKin2$ID2)))," unique individuals with at least 1 relative in raw kinship before filtering.") )


## Basic stats
# number of relatives
nIndsRel = length(unique(c(kin2$ID1,kin2$ID2)))
print( paste0(nIndsRel," unique individuals with at least 1 relative.") )

# SNPs used in kinship inference (second round)
kinSNPs = read.table('/well/ukbiobank/qcoutput.V2_QCed.sample-QC/QC-Scripts/PCA/pca-UKBio/b1__b11-b001__b095-autosome-sampleqc-fastpca-highquality-init-snpsToKeepPCs-0.003.txt',header=FALSE,stringsAsFactors=FALSE)[,1]

print(paste0(length(kinSNPs)," SNPs used in kinship inference."))

kinSNPSrsid = BB.ps2snp$dbSNPRSID[match(kinSNPs,BB.ps2snp$AffySNPID)]

print(paste0(length(intersect(kinSNPSrsid,GenotypesForReleaseBim$V2))," SNPs used in kinship inference and in output genotype data."))

## kinship coefficient histogram
#png(paste0("plots/",releaseSampleQCPrefix,"-kinshipHist.png"),bg="transparent",width=1200,height=1200,res=150)

pdf(paste0("plots/",releaseSampleQCPrefix,"-kinshipHist.pdf"),bg="transparent",width=1200/150,height=1200/150)
hist(kin2$Kinship,breaks=200,main="Kinship coefficients for pairs of UK Biobank participants",
     xlab="Estimated kinship coefficient",xaxt="n",border="black",col="gray35",lwd=0.2)
axis(1,at=seq(0.05,0.5,by=0.05))

abline(v=(0.5)^c(1,2,3,4),col=colDef[kinshipLegendOrder[-3]])
text(x=0.015+(0.5)^c(1,2,3,4),y=2*rev(c(2500,1700,2100,2000)),labels=c("0th degree (monozygotic twins)","1st degree (parent-offspring or siblings)","2nd degree (avuncular, half-siblings, grandparent-grandchild)","3rd degree (e.g cousins)"),srt=90,pos=3,xpd=NA)
dev.off()


## kinship coefficient histogram - before filtering SNPs!!!!!
#png(paste0("plots/",releaseSampleQCPrefix,"-kinshipHist.png"),bg="transparent",width=1200,height=1200,res=150)
pdf(paste0("plots/",releaseSampleQCPrefix,"-kinshipHist-prefiltering.pdf"),bg="transparent",width=1200/150,height=1200/150)
hist(rawKin2$Kinship,breaks=200,main="Kinship coefficients for pairs of UK Biobank participants\nwithout applying SNP filters",
     xlab="Estimated kinship coefficient",xaxt="n",border="black",col="gray35",lwd=0.2)
axis(1,at=seq(0.05,0.5,by=0.05))

abline(v=(0.5)^c(1,2,3,4),col=colDef[kinshipLegendOrder[-3]])
text(x=0.015+(0.5)^c(1,2,3,4),y=25000,labels=c("0th degree (monozygotic twins)","1st degree (parent-offspring or siblings)","2nd degree (avuncular, half-siblings, grandparent-grandchild)","3rd degree (e.g cousins)"),srt=90,pos=3,xpd=NA)
dev.off()


## XY plot of Kinship coefficents before and after SNP filtering
# match up kin2 with pairs in rawKin2
k1 = paste0(kin2$ID1,kin2$ID2)
k2a = paste0(rawKin2$ID1,rawKin2$ID2); k2b = paste0(rawKin2$ID2,rawKin2$ID1);
matches1 = match(k1,k2a)
matches2 = match(k1,k2b)
matches1[is.na(matches1)] = matches2[is.na(matches1)]

kinJoined=full_join(rawKin2,kin2,by=c("ID1"="ID1","ID2"="ID2"))
kinJoined$Kinship.x[is.na(kinJoined$Kinship.x)] = 0
kinJoined$Kinship.y[is.na(kinJoined$Kinship.y)] = 0
# note: nothing matches with IDs the other way!
#kinJoined2=full_join(rawKin2,kin2,by=c("ID1"="ID2","ID2"="ID1"))

x = kinJoined$Kinship.x
y = kinJoined$Kinship.y

hexKin = hexbin(x,y,xbins=100)

pdf(paste0("plots/",releaseSampleQCPrefix,"-kinshipscatter-prefiltering-vs-filtered.pdf"),bg="transparent",width=1200/150,height=1200/150)
pushViewport(viewport(gp= gpar(lineheight=1.3)))
hb = plot(hexKin,xlab="Kinship estimate without SNP filtering",ylab="Kinship estimate using SNP filtering",colramp=viridis,colorcut=c(0,5^seq(0:6)/sum( 5^seq(0:6)),1))
hexVP.abline(hb$plot,0,1, col= "red",lty=3,)
dev.off()

 # using ggplot
myTheme = theme_bw() + theme(aspect.ratio=1)
my_breaks = 10^seq(0,10,1)

data = data.frame(cbind(x,y))

pdf(paste0('plots/',releaseSampleQCPrefix,'-kinshiphexbin-prefiltering-vs-filtered.pdf'),bg="transparent",width=1500/150)

d <- ggplot(data, aes(x=x, y=y)) + stat_binhex(bins=100) +  scale_fill_gradientn(name="Count" ,breaks=rev(my_breaks),trans="log10",colors=viridis_pal()(10)) +  scale_x_continuous( expand = c(0.01, 0.01),name="Kinship estimate without SNP filtering") +
  scale_y_continuous(expand = c(0.01, 0.01),name="Kinship estimate using SNP filtering") + geom_abline(slope=1, intercept=0,color="red",linetype="longdash") + myTheme

print(d)
dev.off()



#x = kinJoined$Kinship.x[kinJoined$Kinship.y!=0]
#y = kinJoined$Kinship.y[kinJoined$Kinship.y!=0]

eth1 = outTable$Ethnic.background[match(kinJoined$ID1,outTable$PIID)]
eth2 = outTable$Ethnic.background[match(kinJoined$ID2,outTable$PIID)]
pop1 = ethnicity2pop(eth1)
pop2 = ethnicity2pop(eth2)
cols = ethnicity2col[pop1]
cols[pop1!=pop2] = "black"
chars = ethnicity2char[pop1]
chars[pop1!=pop2] = 4
Order = order.by.number.occurrences(cols)

pdf(paste0("plots/",releaseSampleQCPrefix,"-kinshipscatter-prefiltering-vs-filteredbyEth.pdf"),bg="transparent",width=1200/150,height=1200/150)
plot(x[Order],y[Order],col=cols[Order],pch=chars[Order],xlab="Kinship estimate without SNP filtering",ylab="Kinship estimate using SNP filtering")
abline(0,1,col="red",lty=3)
dev.off()



## Families and trios
load(paste0('../Sample-QC/Relatedness/',releaseSampleQCPrefix,'_Kinship-families.RData'),verbose=TRUE)

allTrios = read.table(paste0('../Sample-QC/Relatedness/forPhasing/',releaseSampleQCPrefix,'_Kinship-all-trios.txt'),header=TRUE,stringsAsFactors=FALSE)

# quartets within trios
quarts = allTrios[duplicated(allTrios[,2]),]
dupeParents = apply(quarts,1,function(x) {
    qs = allTrios[(allTrios[,2]==x[2])&(allTrios[,3]==x[3]),]
#   print(dim(qs))
})

nQuartets = sum(sapply(dupeParents,function(x) dim(x)[1]==2))

print( paste0(nrow(allTrios)," trios."))
print( paste0(nrow(unique(allTrios[,2:3]))," unique parent sets."))
print( paste0(nQuartets," unique quartets."))


# Basic family sizes    
png(paste0("plots/",releaseSampleQCPrefix,"-FamilySizes-Log.png"),bg="transparent",width=2000,height=1500,res=150)
par(cex.axis=0.8,mgp=c(2,1,0))
barplot(table(fams$csize),main="Family sizes including 3rd degree",log="y",xlab="Family size",ylab="Count of families",col="darkgrey")

axisTicks=seq(0,round(max(log10(table(fams$csize)))),by=1)
axisLabels= sapply(axisTicks, function(i) as.expression(bquote(10^ .(i))))
axisLabels[1:2]=c(1,10)
axis(2,at=axisTicks,labels=axisLabels,xpd=NA,las=2)

dev.off()

png(paste0("plots/",releaseSampleQCPrefix,"-FamilySizes-no3degree-Log.png"),bg="transparent",width=1500,height=1500,res=150)
par(cex.axis=0.8,mgp=c(2,1,0))
barplot(table(famsNo3$csize),main="Family sizes excluding 3rd degree",log="y",xlab="Family size",ylab="Count of families",col="darkgrey")
dev.off()

           
# Number of relatives by type <========= Not sure this is correct, as total number of individuals don't add up... <==== now fixed!!
bins = c(0:10,20,Inf)

k0 = kin2$class==kinshipLegendOrder[1] #"dupe/twins"
k1a = kin2$class==kinshipLegendOrder[2] #"parent/child"
k1b = kin2$class==kinshipLegendOrder[3] #"sibs"
k2 = kin2$class==kinshipLegendOrder[4] #"2nd degree"
k3 = kin2$class==kinshipLegendOrder[5] #"3rd degree"

nKins = table(c(kin2$ID1,kin2$ID2)) # how many relatives does each person have?

hists = sapply(2:length(bins),function(n){
    print(n)
    N = c(bins[n-1],bins[n])
    inds = names(nKins)[( nKins > N[1] )&( nKins <= N[2] )]
    total = length(inds)

    
    #t0 = sum(inds%in%c(kin2$ID1[k0],kin2$ID2[k0]))
    #t1a = sum(inds%in%c(kin2$ID1[k1a],kin2$ID2[k1a]))
    #t1b = sum(inds%in%c(kin2$ID1[k1b],kin2$ID2[k1b]))
    #t2 = sum(inds%in%c(kin2$ID1[k2],kin2$ID2[k2]))
    #t3 = sum(inds%in%c(kin2$ID1[k3],kin2$ID2[k3]))
    
    # alternative sum. How much of each of the samples' relatives is in each kinship class. THe sum will be N*total. Note this in the legend1
    #these = (kin2$ID1%in%inds)|(kin2$ID2%in%inds) # total number of pairs with one of the inds in it.
    #t = table(c(kin2$ID1[these & k0],kin2$ID2[these & k0]))
    #t0 = sum(t[names(t)%in%inds])
    #t = table(c(kin2$ID1[these & k1a],kin2$ID2[these & k1a]))
    #t1a = sum(t[names(t)%in%inds])
    #t = table(c(kin2$ID1[these & k1b],kin2$ID2[these & k1b]))
    #t1b = sum(t[names(t)%in%inds])
    #t = table(c(kin2$ID1[these & k2],kin2$ID2[these & k2]))
    #t2 = sum(t[names(t)%in%inds])
    #t = table(c(kin2$ID1[these & k3],kin2$ID2[these & k3]))
    #t3 = sum(t[names(t)%in%inds])
    
    # then count how many pairs contain each relative class. This means that if two inds are in the same pair (likely for some) then this is only counted once.
    #t0 = sum(these&k0)
    #t1a = sum(these&k1a)
    #t1b = sum(these&k1b)
    #t2 = sum(these&k2)
    #t3 = sum(these&k3)
    # make these sum to the totalnumber of indiviausl.
    
    #div = c(t0,t1a,t1b,t2,t3)
    #div2 = total*(div/sum(div))
    #print(sum(div2) == total)
    #return(div2)

##### NEW suggested by Peter. Count the classes of pairs that EACH individual is involved in, and then compute the fraction of each classes among the k*n counts, where n is number of individuals, and k is the number of relatives in this bin.

    
    these = (kin2$ID1%in%inds)|(kin2$ID2%in%inds) # total number of pairs with one of the inds in it.

    t = table(c(kin2$ID1[these & k0],kin2$ID2[these & k0]))
    t0 = sum(t[names(t)%in%inds])
    t = table(c(kin2$ID1[these & k1a],kin2$ID2[these & k1a]))
    t1a = sum(t[names(t)%in%inds])
    t = table(c(kin2$ID1[these & k1b],kin2$ID2[these & k1b]))
    t1b = sum(t[names(t)%in%inds])
    t = table(c(kin2$ID1[these & k2],kin2$ID2[these & k2]))
    t2 = sum(t[names(t)%in%inds])
    t = table(c(kin2$ID1[these & k3],kin2$ID2[these & k3]))
    t3 = sum(t[names(t)%in%inds])
    
    div = c(t0,t1a,t1b,t2,t3)
    print((sum(div)/total) == (n-1))

    div2 = total*(div/sum(div))  # <== The total number of connections counted won't be exactly the total number of individuals. It will always be total*bin, except when the bin contains more than one type (e.g 11-20 or 21+). This means we can use the colsums for the height of the bars, and the proportion in each category as the fractions. 
    print(sum(div2) == total)
    

    return(div2)
})

rownames(hists)=kinshipLegendOrder
histFracs = t(t(hists)/rowSums(t(hists)))

nKinsNo3 = table(c(kin2$ID1[!k3],kin2$ID2[!k3]))

histsNo3 = sapply(2:length(bins),function(n){
    print(n)
    N = c(bins[n-1],bins[n])
    inds = names(nKinsNo3)[( nKinsNo3 > N[1] )&( nKinsNo3 <= N[2] )]
    total = length(inds)
    t0 = sum(inds%in%c(kin2$ID1[k0],kin2$ID2[k0]))
    t1a = sum(inds%in%c(kin2$ID1[k1a],kin2$ID2[k1a]))
    t1b = sum(inds%in%c(kin2$ID1[k1b],kin2$ID2[k1b]))
    t2 = sum(inds%in%c(kin2$ID1[k2],kin2$ID2[k2]))
    
    div = c(t0,t1a,t1b,t2)
    sum(div) == total
    return(div)
})

rownames(histsNo3)=kinshipLegendOrder[-5]
histFracsNo3 = t(t(histsNo3)/rowSums(t(histsNo3)))


binNames = bins[-1];
binNames[length(binNames)-1]="11-20"
binNames[length(binNames)]="21+"


## Number of relatives by ethnic background!
y = table(c(kin2$ID1[kin2$class=="3rd degree"],kin2$ID2[kin2$class=="3rd degree"]))
x = outTable$heterozygosity.pc.corrected[match(names(y),outTable$PIID)]
eth = outTable$Ethnic.background[match(names(y),outTable$PIID)]
pop = ethnicity2pop(eth)
pop = factor(pop,levels=ethnicities[ethnicityOrder][ethnicities[ethnicityOrder]%in%pop] )
 # only include tho

png(paste0("plots/",releaseSampleQCPrefix,"-Nrelatives-by-eth-boxplot.png"),bg="transparent",width=1200,height=1200,res=200)
par(mar=c(12,3,4,1),cex=0.8)
boxplot(y~pop,ylim=c(0,1000),las=2,outline=F,main="Number of 3rd degree relatives\nafter applying SNP filter")

for( i in 1:length(levels(pop))){    
    stripchart(y[pop==levels(pop)[i]], at = i, vertical = TRUE,jitter = 0.25, cex=0.8,xpd=NA,
               add = TRUE, method = "jitter",pch = ethnicity2char[levels(pop)[i]],axes=FALSE,col = add.alpha(ethnicity2col[levels(pop)[i]],0.6))
}
dev.off()


# raw kinship estimates (before snp filtering)
y = table(c(rawKin2$ID1[rawKin2$class=="3rd degree"],rawKin2$ID2[rawKin2$class=="3rd degree"]))
x = outTable$heterozygosity.pc.corrected[match(names(y),outTable$PIID)]
eth = outTable$Ethnic.background[match(names(y),outTable$PIID)]
pop = ethnicity2pop(eth)
pop = factor(pop,levels=ethnicities[ethnicityOrder][ethnicities[ethnicityOrder]%in%pop] )
 # only include those that are in the transformed ethnic groupings


png(paste0("plots/",releaseSampleQCPrefix,"-Nrelatives-by-eth-boxplot-prefiltering.png"),bg="transparent",width=1200,height=1200,res=200)
par(mar=c(12,3,4,1),cex=0.8)
boxplot(y~pop,ylim=c(0,1000),las=2,outline=F,main="Number of 3rd degree relatives\nwithout applying SNP filter")

for( i in 1:length(levels(pop))){    
    stripchart(y[pop==levels(pop)[i]], at = i, vertical = TRUE,jitter = 0.25, cex=0.8,
               add = TRUE, method = "jitter",pch = ethnicity2char[levels(pop)[i]],axes=FALSE,col = add.alpha(ethnicity2col[levels(pop)[i]],0.6))
}

dev.off()

# Why are there the blobs at 800 and 200? Are they all related to each other?
set1 = names(y)[(y<900)&(y>700)] # blob around 800
set2 = names(y)[which((y<250)&(y>150)&(eth!="Chinese"))] # blob around 200

rawKin2subset1 = rawKin2[( (rawKin2$ID1%in%c(set1))&(rawKin2$ID2%in%c(set1)) )&(rawKin2$class=="3rd degree")&(rawKin2$ID1!="A550484-4214750-042215-077_H10"),!colnames(rawKin2)%in%c("FID1","FID2")]

rawKin2subset2 = rawKin2[( (rawKin2$ID1%in%c(set2))&(rawKin2$ID2%in%c(set2)) )&(rawKin2$class=="3rd degree")&(rawKin2$ID1!="A550484-4214750-042215-077_H10"),!colnames(rawKin2)%in%c("FID1","FID2")]

 # "A550484-4214750-042215-077_H10" is part of a lone pair.
# names(famsSubSet1$membership)[famsSubSet1$membership==2]

# Construct the graphs...
networkSet1 <- graph.data.frame(rawKin2subset1, directed=F)
famsSubSet1 = clusters(networkSet1)
V(networkSet1)$color <- ethnicity2col[ethnicity2pop(outTable$Ethnic.background[match(V(networkSet1)$name,outTable$PIID)])]
E(networkSet1)$color <- "black"

png(paste0("plots/",releaseSampleQCPrefix,"-Nrelatives800-graph-prefiltering.png"),bg="transparent",width=2000,height=2000,res=200)
plot.igraph(networkSet1,main=paste0(length(set1)," samples and ",nrow(rawKin2subset1)," 'pairs'"),vertex.frame.color=NA,vertex.label=NA,vertex.size=0.5,vertex.shape="circle")

dev.off()


networkSet2 <- graph.data.frame(rawKin2subset2, directed=F)
famsSubSet2 = clusters(networkSet2)
V(networkSet2)$color <- ethnicity2col[ethnicity2pop(outTable$Ethnic.background[match(V(networkSet2)$name,outTable$PIID)])]
E(networkSet2)$color <- "black"

png(paste0("plots/",releaseSampleQCPrefix,"-Nrelatives200-graph-prefiltering.png"),bg="transparent",width=2000,height=2000,res=200)
plot.igraph(networkSet2,main=paste0(length(set2)," samples and ",nrow(rawKin2subset2)," 'pairs'"),vertex.frame.color=NA,vertex.label=NA,vertex.size=0.5,vertex.shape="circle")

dev.off()



## Barplots of Nrelatives (final data)
#png(paste0("plots/",releaseSampleQCPrefix,"-barplotNRelatives.png"),bg="transparent",width=1200,height=1000,res=150)
pdf(paste0("plots/",releaseSampleQCPrefix,"-barplotNRelatives.pdf"),bg="transparent",width=1200/150,height=1000/150)
par(cex.axis=0.8,mgp=c(2,1,0))
b=barplot(hists[rev(kinshipLegendOrder),],xaxt="n",xlab="Number of relatives per participant",ylab=NA,col=colDef[rev(kinshipLegendOrder)])
axis(1,at=b,labels=binNames,line=-0.5,lwd=0,tick=FALSE)
mtext(text="Number of participants",side=2,line=3)
#mtext(text="Number of participants",side=2)
legend("top",legend=kinNames[kinshipLegendOrder],col="black",pt.bg=colDef[kinshipLegendOrder],pch=22)
dev.off()


#png(paste0("plots/",releaseSampleQCPrefix,"-barplotNRelatives-Log.png"),bg="transparent",width=1200,height=1000,res=150)
pdf(paste0("plots/",releaseSampleQCPrefix,"-barplotNRelatives-Log.pdf"),bg="transparent",width=1200/230,height=1000/230)
par(cex.axis=0.7,mgp=c(2,1,0))

b = barplot(log10(colSums(hists)),xaxt="n",xlab="Number of relatives per participant",
    ylab=NA,col="transparent",border="black",
    yaxt="n",cex.lab=0.8)
mtext(text="Number of participants",side=2,line=3,cex=0.8)

axisTicks=seq(0,round(max(log10(colSums(hists)))),by=1)
axisLabels= sapply(axisTicks, function(i) as.expression(bquote(10^ .(i))))
axisLabels[1:2]=c(1,10)
axis(2,at=axisTicks,labels=axisLabels,xpd=NA,las=2)
                                        # add in colours to represent fractions
for(i in 1:ncol(histFracs) ) {
    topRecs = log10(sum(hists[rev(kinshipLegendOrder),i]))*cumsum(histFracs[rev(kinshipLegendOrder),i])
    bottomRecs = c(0,topRecs[-length(topRecs)])
    rect(rep(b[i]-0.5,length(topRecs)),bottomRecs,rep(b[i]+0.5,length(topRecs)),topRecs,col=colDef[rev(kinshipLegendOrder)],border=NA)
}
barplot(log10(colSums(hists)),xaxt="n", yaxt="n",col="transparent",border="black",add=TRUE)

axis(1,at=b,labels=binNames,line=-0.5,lwd=0,tick=FALSE)
#legend("top",legend=kinNames[kinshipLegendOrder],col="black",pt.bg=colDef[kinshipLegendOrder],pch=22)
dev.off()


png(paste0("plots/",releaseSampleQCPrefix,"-barplotNRelatives-no3degree-Log.png"),bg="transparent",width=1200,height=1000,res=150)
par(cex.axis=0.8,mgp=c(2,1,0))
toPlot = log10(colSums(histsNo3)); toPlot[toPlot==-Inf]=0
b = barplot(toPlot,xaxt="n",xlab="Number of relatives per participant",
    ylab=NA,col="transparent",border="black",
    yaxt="n")
mtext(text="Number of participants",side=2,line=3)

axisTicks=seq(0,round(max(log10(colSums(histsNo3)))),by=1)
axisLabels= sapply(axisTicks, function(i) as.expression(bquote(10^ .(i))))
axisLabels[1:2]=c(1,10)
axis(2,at=axisTicks,labels=axisLabels,xpd=NA,las=2)
                                        # add in colours to represent fractions
for(i in 1:ncol(histFracs) ) {
    topRecs = log10(sum(histsNo3[rev(kinshipLegendOrder[kinshipLegendOrder%in%rownames(histFracsNo3)]),i]))*cumsum(histFracsNo3[rev(kinshipLegendOrder[kinshipLegendOrder%in%rownames(histFracsNo3)]),i])
    bottomRecs = c(0,topRecs[-length(topRecs)])
    rect(rep(b[i]-0.5,length(topRecs)),bottomRecs,rep(b[i]+0.5,length(topRecs)),topRecs,col=colDef[rev(kinshipLegendOrder[kinshipLegendOrder%in%rownames(histFracsNo3)])],border=NA)
}
barplot(toPlot,xaxt="n", yaxt="n",col="transparent",border="black",add=TRUE)

axis(1,at=b,labels=binNames,line=-0.5,lwd=0,tick=FALSE)
legend("top",legend=kinNames[kinshipLegendOrder[kinshipLegendOrder%in%rownames(histFracsNo3)]],col="black",pt.bg=colDef[kinshipLegendOrder[kinshipLegendOrder%in%rownames(histFracsNo3)]],pch=22)
dev.off()




#### Examples of interesting families

# High connectivity
# just compute over 5 or more families
famsNo34 = which(famsNo3$csize>4)
connectivityNo3 = sapply(famsNo34,function(f){
    print(f)
    inds = names(famsNo3$membership)[famsNo3$membership==f]
    subGraph = igraph::induced_subgraph(networkNo3,inds,impl="copy_and_delete")
    con = edge_connectivity(subGraph)
    return(con)
})
names(connectivityNo3) = famsNo34

highConnectivityNo3 = as.numeric(names(connectivityNo3)[connectivityNo3>3])
table(famsNo3$csize[highConnectivityNo3])

highConnectExamples = c(12104,6099,10007,3528,3317,5189)

# Trios
triosNoQuart = allTrios[!allTrios[,1]%in%quarts[,1],]
trioFams = famsNo3$membership[triosNoQuart[,1]]
triosExamples = c(trioFams[which(famsNo3$csize[trioFams]==3)][1], # lone trios
    trioFams[which(famsNo3$csize[trioFams]==4)][1]) #  trios with something else

# quartets
quartFams = famsNo3$membership[quarts[,1]]
table( famsNo3$csize[quartFams] )
quartsExamples = c(quartFams[which(famsNo3$csize[quartFams]==4)][1], # lone quartets
    quartFams[which(famsNo3$csize[quartFams]==5)][1],
    quartFams[which(famsNo3$csize[quartFams]==6)][1]) #  quartets with something else

# twin mothers
twinMums = read.table(paste0('../Sample-QC/Relatedness/forPhasing/',releaseSampleQCPrefix,'_Kinship-all-trios-twinMothers.txt'),header=TRUE,stringsAsFactors=FALSE)
twinMumFams = famsNo3$membership[twinMums[,1]]
table( famsNo3$csize[twinMumFams] )
twinMumExample = twinMumFams[1]



ExampleFamilies = c(highConnectExamples,triosExamples,quartsExamples,twinMumExample)
inds = names(famsNo3$membership)[famsNo3$membership%in%ExampleFamilies]

# find any third-degree relatives
indsRels=unlist(sapply(inds,function(x) V(network)$name[neighbors(network, x)]))
subGraph1 = igraph::induced_subgraph(network,c(inds,indsRels),impl="copy_and_delete")
famIDs1 = getFamLabels(inds,famsNo3,subGraph1)
for(class in names(kinWeights)){
    # apply edge-weights
    E(subGraph1)$weight[E(subGraph1)$class%in%class] <- kinWeights[class]/3
}

# get counts of family configurations
famFreqs = sapply(ExampleFamilies,function(f){
    thisConfig = famsNo33Configs[,as.character(f)]
    ind = names(famsNo3$membership)[famsNo3$membership==f]
    indFam = fams$membership[ind]  # family id including 3rd degree
    thisConfig2 = fams3Configs[,as.character(unique(indFam))]
    print(as.character(f))
    print( length(unique(indFam)) )

    others = apply(famsNo33Configs,2,function(x) sum(x==thisConfig)==length(thisConfig))
    print( sum(others) )

    others2 = apply(fams3Configs,2,function(x) sum(x==thisConfig2)==length(thisConfig2))
    print( sum(others2) )
    
    return(c(sum(others),sum(others2)))
})
colnames(famFreqs) = as.character(ExampleFamilies)
famFreqs = famFreqs[1,match(as.character(famIDs1),colnames(famFreqs))] # The number of other families with exactly the same types of related pairs after excluding 3rd degree.
famFreqs[famFreqs==1]=NA

set.seed(12345)
png(paste0("plots/",releaseSampleQCPrefix,"-families-interesting-examples-graph-%02d.png"),bg="transparent",width=1500,height=1500,res=150)
# with labels
plot.igraph(subGraph1,main=paste0("Example family groups"),vertex.frame.color=NA,vertex.label=famIDs1,vertex.size=2,vertex.shape="circle",edge.width=E(subGraph1)$weight,vertex.label.color="black",vertex.label.family="Arial",vertex.label.dist=0.5)
# without labels
plot.igraph(subGraph1,main=paste0("Example family groups"),vertex.frame.color=NA,vertex.label=NA,vertex.size=2,vertex.shape="circle",edge.width=E(subGraph1)$weight)
# With labels indicating numbers of such families
plot.igraph(subGraph1,main=paste0("Example family groups"),vertex.frame.color=NA,vertex.label=famFreqs,vertex.size=2,vertex.shape="circle",edge.width=E(subGraph1)$weight,vertex.label.color="black",vertex.label.family="Arial",vertex.label.dist=1.5)

dev.off()

                                        # the third one has best layout. PDF versions.
set.seed(12345)
pdf(paste0("plots/",releaseSampleQCPrefix,"-families-interesting-examples-graph-1.pdf"),bg="transparent",width=1500/150,height=1500/150)
plot.igraph(subGraph1,main=paste0("Example family groups"),vertex.frame.color=NA,vertex.label=famIDs1,vertex.size=2,vertex.shape="circle",edge.width=E(subGraph1)$weight,vertex.label.color="black",vertex.label.family="sans",vertex.label.dist=0.5)
dev.off()                                        # without labels
pdf(paste0("plots/",releaseSampleQCPrefix,"-families-interesting-examples-graph-2.pdf"),bg="transparent",width=1500/150,height=1500/150)
plot.igraph(subGraph1,main=paste0("Example family groups"),vertex.frame.color=NA,vertex.label=NA,vertex.size=2,vertex.shape="circle",edge.width=E(subGraph1)$weight)
dev.off()
pdf(paste0("plots/",releaseSampleQCPrefix,"-families-interesting-examples-graph-3.pdf"),bg="transparent",width=1500/150,height=1500/150)
# With labels indicating numbers of such families
plot.igraph(subGraph1,main=paste0("Example family groups"),vertex.frame.color=NA,vertex.label=famFreqs,vertex.size=2,vertex.shape="circle",edge.width=E(subGraph1)$weight,vertex.label.color="black",vertex.label.family="sans",vertex.label.dist=1.5)
dev.off()

# plot them separately
png(paste0("plots/",releaseSampleQCPrefix,"-families-interesting-examples-graph-separate-plots-%02d.png"),bg="transparent",width=500,height=500,res=150,cex=2)
for( f in ExampleFamilies){
    print(f)
    inds = names(famsNo3$membership)[famsNo3$membership%in%f]
    indsRels=unlist(sapply(inds,function(x) V(subGraph1)$name[neighbors(subGraph1, x)]))
    thisGraph = igraph::induced_subgraph(subGraph1,c(inds,indsRels),impl="copy_and_delete")

    plot.igraph(thisGraph,main=paste0("Family ID: ",f),vertex.frame.color=NA,vertex.label=NA,vertex.size=2,vertex.shape="circle",edge.width=E(subGraph1)$weight)
}

dev.off()


# plot LEGEND
#png(paste0("plots/",releaseSampleQCPrefix,"-families-LEGEND.png"),bg="transparent",width=1500,height=1500,res=150)
pdf(paste0("plots/",releaseSampleQCPrefix,"-families-LEGEND.pdf"),bg="transparent",width=1500/150,height=1500/150)
par(cex=3)
plot(NULL,xlim=c(0,1),ylim=c(0,1),axes=FALSE,xlab=NA,ylab=NA)
legend("top",legend=kinNames[kinshipLegendOrder],col=colDef[kinshipLegendOrder],lwd=kinWeights[kinshipLegendOrder])
dev.off()



#################################
# The BARTON BROOD!
#################################

brood = names(famsNo3$membership)[famsNo3$membership==3528]
broodKin = kin2[(kin2$ID1%in%brood)&(kin2$ID2%in%brood),]
broodInfo = outTable[match(brood,outTable$PIID),]
# 55 pairs
png( paste0("plots/",releaseSampleQCPrefix,"-brood-Kinship-boxplog.png"),bg="transparent",width=500,height=1000,res=150 )
boxplot( broodKin$Kinship ,ylim=range(kin2$Kinship[kin2$class=="2nd degree"]),ylab="Kinship coefficient")
abline(h=1/8,col="red",lty=3)
stripchart(broodKin$Kinship,vertical=TRUE,method="jitter",col=ethnicity2col["British"],pch=16,add=TRUE)
dev.off()

# Fraction passed on = 0.5 + 0.5( 1-(k12) ) + 0.5( 1-(k12 + k23 - k12*k23) ) + 0.5( 1-(k14 + k24 + k34 - k14*k24*k34) ) + ...
nonKinship = (1-broodKin$Kinship)
kins = c(0.5,sapply(2:length(nonKinship), function(i) 0.5[1 - prod(nonKinship[1:i]) ))

sibs=rep(0.25,55)
    
#sapply(1:length(brood),function(i){
    ind = brood[i]
    prevInds = brood[1:(i-1)]
    kinships = broodKin$Kinship[ ( (broodKin$ID1==ind) & (broodKin$ID2%in% prevInds)) | ( (broodKin$ID2==ind) & (broodKin$ID1%in% prevInds))]
    1 - (sum(kinships) - prod(kinships))
    })
    
#c(0.5,sapply(2:length(sibs), function(i) prod(1-sibs[1:i]) ))



#################################
# Ethnicity
#################################

pop = ethnicity2pop2(outTable$Ethnic.background)
pop2 = getEthCat(pop,cats=ethnicityCats3)
ethCounts = table(pop)
ethFreq = ethCounts/nInds; ethFreqTopCat = getEthCat(names(ethFreq),cats=ethnicityCats3)
topCatCounts = table(pop2)
topCatFreq = topCatCounts/nInds

ethnicityTab = cbind.data.frame(ethFreqTopCat,ethFreq,as.vector(ethCounts),stringsAsFactors=FALSE)
ethnicityTab[,2]=as.character(ethnicityTab[,2])
colnames(ethnicityTab) = c("Category","Ethnic background","Frequency","Count")
ethnicityTab = ethnicityTab[order(ethnicityTab$Frequency,decreasing=TRUE),]

ethnicityTab2 = ethnicityTab[0,,drop=FALSE]
ethOrder = c(unique(ethnicityTab$Category[ethnicityTab$Category!="Other/Unknown"]),"Other/Unknown");

for(i in ethOrder){
count1 = format(ethnicityTab$Count[ethnicityTab$Category==i],trim=TRUE,big.mark=",")
countTop = format(topCatCounts[i],trim=TRUE,big.mark=",")
#fr = c("",round(100*ethnicityTab$Frequency[ethnicityTab$Category==i],2))
#catFr = c(round( 100*topCatFreq[i],2),rep("",sum(ethnicityTab$Category==i)))
fr = c("",paste0(count1," (",round(100*ethnicityTab$Frequency[ethnicityTab$Category==i],2),"%)"))
catFr = c(paste0(countTop," (",round( 100*topCatFreq[i],2),"%)"),rep("",sum(ethnicityTab$Category==i)))

pops = c("",ethnicityTab$`Ethnic background`[ethnicityTab$Category==i])
cats = c(i,rep("",sum(ethnicityTab$Category==i)))

if(sum(ethnicityTab$Category==i)>1) ethnicityTab2 = rbind(ethnicityTab2,cbind(cats,pops,fr,catFr)) else ethnicityTab2 = rbind(ethnicityTab2,cbind(cats,pops,fr,catFr)[1,,drop=FALSE])

}

colnames(ethnicityTab2) = c("","Self-reported ethnic background","In UK Biobank genotype data (\\%)","")

write.table(ethnicityTab,file=paste0(releaseSampleQCPrefix,"-EthnicityInfoTable.txt"),quote=FALSE,col.names=TRUE,row.names=FALSE,sep="\t")
#write.table(ethnicityTab2,file=paste0(releaseSampleQCPrefix,"-EthnicityInfoTable2.txt"),quote=FALSE,col.names=TRUE,row.names=FALSE,sep="\t")
write.table(ethnicityTab2,file=paste0(releaseSampleQCPrefix,"-EthnicityInfoTable3.txt"),quote=FALSE,col.names=TRUE,row.names=FALSE,sep="\t")

xTab = xtable(ethnicityTab2, caption = NULL, label = NULL, align = NULL, display = NULL)
#digits(xTab) <- xdigits(xTab)
align(xTab) = paste(c("|l|",rep("l",ncol(ethnicityTab2)),"|"),collapse="")
#align(xTab)=xalign(xTab)
forHline = which(ethnicityTab2[,1]!="")-1

#sink(file=paste0(releaseSampleQCPrefix,"-EthnicityInfoTable.tex"))
sink(file=paste0(releaseSampleQCPrefix,"-EthnicityInfoTable3.tex"))
                                        #print(xTab,size="small",hline.after=c(forHline,dim(ethnicityTab2)[1]),include.rownames = TRUE,sanitize.colnames.function = bold,booktabs = TRUE)
#print(xTab,size="small",include.rownames = TRUE,sanitize.colnames.function = bold,booktabs = TRUE)
print(xTab,size="small",hline.after=c(-1,forHline,dim(ethnicityTab2)[1]),sanitize.colnames.function = bold,include.rownames = FALSE)

sink()




#################################
# PCA
#################################

PCs = outTable[,grepl("PC",colnames(outTable))]
nPCs = ncol(PCs)
print(paste0(nPCs," PCs"))

## Plot the first XX PCs by ethnic background
eth = outTable$Ethnic.background
pop = ethnicity2pop(eth)

Colors = ethnicity2col[pop]
Chars = ethnicity2char[pop]

# NOTE FOR LEGEND:  The groupings are in a tree-like structure. 'British' refers to British under the subercategory 'white'. We actually used a slightly different categorisation in the ethnicity table.
Order = order.by.number.occurrences(pop)
#Order = Order[sort(sample(1:length(Order),2000,replace=FALSE))]

png(paste0('plots/',releaseSampleQCPrefix,'-PCA-%02d.png'),bg="transparent",width=2*3*1500,height=2*3*1500,res=450*2)
par(cex.lab=1.5,mar=c(5.1,5.1,3,2))
#for (pc in 1:nPCs){
for (pc in 1:3){

if( pc==3 ){
    par(cex.lab=2,mar=c(5.1,5.1,3,2),cex.axis=1.5)

}
    if(pc%%2==0) next

    print(paste0('Plotting PCs',pc,' and ',pc + 1))

    x = PCs[[paste0("PC",pc)]]
    y = PCs[[paste0("PC",pc+1)]]

    plot(x[Order],y[Order],xlab=paste0('PC ',pc),ylab=paste0('PC ',pc+1),
         col=add.alpha(Colors[Order],0.3),pch=Chars[Order])#,axes=FALSE)    
#    axis(1,cex.lab=1.3)
#    axis(2,cex.lab=1.3)

}

dev.off()

                                        # EPS version for pcs 1-4

pc = 1
postscript(paste0('plots/',releaseSampleQCPrefix,'-PCA-',pc,'.eps'),bg="transparent",width=5,height=5,onefile=FALSE, horizontal = FALSE,paper='special')
#par(cex.lab=1.5,mar=c(5.1,5.1,3,2),ps=12)
par(mar=c(5.1,5.1,3,2),ps=12)

x = PCs[[paste0("PC",pc)]]
y = PCs[[paste0("PC",pc+1)]]

plot(x[Order],y[Order],xlab=paste0('PC ',pc),ylab=paste0('PC ',pc+1),
     col=Colors[Order],pch=Chars[Order])#,axes=FALSE)    
dev.off()

pc = 3
postscript(paste0('plots/',releaseSampleQCPrefix,'-PCA-',pc,'.eps'),bg="transparent",width=5,height=5,onefile=FALSE, horizontal = FALSE,paper='special')
#par(cex.lab=1.5,mar=c(5.1,5.1,3,2),ps=12)
par(mar=c(5.1,5.1,3,2),ps=12)

x = PCs[[paste0("PC",pc)]]
y = PCs[[paste0("PC",pc+1)]]

plot(x[Order],y[Order],xlab=paste0('PC ',pc),ylab=paste0('PC ',pc+1),
     col=Colors[Order],pch=Chars[Order])#,axes=FALSE)    
dev.off()



# Plot pdf of first 6 pcs

for (pc in 1:6){
    
if(pc%%2==0) next
    print(paste0('Plotting PCs',pc,' and ',pc + 1))
pdf(paste0('plots/',releaseSampleQCPrefix,'-PCA-',pc,'.pdf'),bg="transparent",width=1500/150,height=1500/150)
par(cex.lab=1.5,mar=c(5.1,5.1,3,2))

    x = PCs[[paste0("PC",pc)]]
    y = PCs[[paste0("PC",pc+1)]]

    plot(x[Order],y[Order],xlab=paste0('PC ',pc),ylab=paste0('PC ',pc+1),
         col=Colors[Order],pch=Chars[Order],axes=FALSE)    
#    axis(1,cex.lab=1.3)
#    axis(2,cex.lab=1.3)

dev.off()
}


## Plot all pairs of first 6 pcs in a grid
#Order=sample(Order,1000,replace=FALSE)
printPCs = 6

png(paste0('plots/',releaseSampleQCPrefix,'-PCA-grid-allpairs',printPCs,'-%02d.png'),bg="transparent",width=3*1500,height=3*1500,res=450)

    plot.grid.PCs(as.data.frame(PCs[Order,grepl("PC",colnames(PCs))]),n=6,maxPC=printPCs,shapes=Chars[Order],colours=Colors[Order],cex.axis=0.5)

dev.off()

#remove odd-numbered pages!
sapply(seq(1,nPCs,by=2),function(i) system(paste0("rm plots/",releaseSampleQCPrefix,'-PCA-grid-allpairs',printPCs,'-0',i,'.png')))


#par(cex.lab=3,mar=c(5.1,5.1,3,2))
#for(pc1 in 1:printPCs){

#for(pc2 in 1:printPCs){
    
#    if(pc2<=pc1) next

#    print(paste0('Plotting PCs',pc1,' and ',pc2))

#    x = PCs[[paste0("PC",pc1)]]
#    y = PCs[[paste0("PC",pc2)]]

#    plot(x[Order],y[Order],xlab=paste0('PC ',pc1),ylab=paste0('PC ',pc2),
#         col=Colors[Order],pch=Chars[Order],cex=1.2)#,axes=FALSE)    
                                        #    axis(1,cex.lab=1.3)
                                        #    axis(2,cex.lab=1.3)
#}
#}
#dev.off()


## Plot using a grid

printPCs = 6

png(paste0('plots/',releaseSampleQCPrefix,'-PCA-grid-%02d.png'),bg="transparent",width=1500,height=1500,res=150)
# if number of PCs is less than 10, and also uneven...
if(printPCs <= 10) {
    
    plot.grid.PCs(as.data.frame(PCs[Order,grepl("PC",colnames(PCs))]),n=6,shapes=Chars[Order],colours=Colors[Order])
 
} else {
    sequence = seq(1,nPCs,10)

    for(l in sequence){
        print(l)
        plot.grid.PCs(as.data.frame(PCs[Order,paste0("PC",c(l:(l+min(9,(nPCs-l)) )))]),shapes=Chars[Order],colours=Colors[Order])
    }
}
dev.off()

#remove odd-numbered pages!
sapply(seq(1,nPCs,by=2),function(i) system(paste0("rm plots/",releaseSampleQCPrefix,'-PCA-grid-0',i,'.png')))



# plot the legend separately
                                        #png(paste0('plots/',releaseSampleQCPrefix,'-PCA-LEGEND.png'),bg="transparent",width=3*1500,height=3*1500,res=450)
pdf(paste0('plots/',releaseSampleQCPrefix,'-PCA-LEGEND.pdf'),bg="transparent",width=1500/150,height=1500/150)
plot.new()
eths1 = ethnicities[ethnicityOrder]  # raw ethnic groupings
legend("topleft",legend=eths1,col=ethnicity2col[eths1],pch=ethnicity2char[eths1],pt.lwd=2,horiz=F,bty="n",title="Ethnic background")
eths2 = ethnicities[ethnicityOrder][ethnicities[ethnicityOrder]%in%pop]  # only include those that are in the transformed ethnic groupings
legend("topright",legend=eths2,col=ethnicity2col[eths2],pch=ethnicity2char[eths2],pt.lwd=2,horiz=F,bty="n",title="Ethnic background")
dev.off()

# Table of counts
#png(paste0('plots/',releaseSampleQCPrefix,'-PCA-LegendCounts.png'),bg="transparent",width=1500,height=1500,res=150)
pdf(paste0('plots/',releaseSampleQCPrefix,'-PCA-LegendCounts.pdf'),bg="transparent",width=1500/150,height=1500/150)
plot.new()
tab = sort(table(pop),decreasing=T)
eths = names(tab)
perc = 100*tab/sum(tab)
perc = c(paste0("(",round(perc,2),"%)"),NA)
legend("topleft",legend=c(tab,sum(tab)),col=c(ethnicity2col[eths],"transparent"),pch=c(ethnicity2char[eths],1),pt.lwd=2,horiz=F,bty="n")
legend("topleft",legend=perc,col="transparent",inset=c(0.08,0),pch=NA,horiz=F,bty="n")
legend("topleft",legend=paste0("\t\t",c(eths,"Total")),col="transparent",inset=c(0.17,0),pch=NA,horiz=F,bty="n")
dev.off()

# Table of counts with British (White)
#png(paste0('plots/',releaseSampleQCPrefix,'-PCA-LegendCounts.png'),bg="transparent",width=1500,height=1500,res=150)
pdf(paste0('plots/',releaseSampleQCPrefix,'-PCA-LegendCounts2.pdf'),bg="transparent",width=1500/150,height=1500/150)
plot.new()
tab = sort(table(pop),decreasing=T)
eths = names(tab)
perc = 100*tab/sum(tab)
perc = c(paste0("(",round(perc,2),"%)"),NA)
legend("topleft",legend=c(tab,sum(tab)),col=c(ethnicity2col[eths],"transparent"),pch=c(ethnicity2char[eths],1),pt.lwd=2,horiz=F,bty="n")
legend("topleft",legend=perc,col="transparent",inset=c(0.08,0),pch=NA,horiz=F,bty="n")
eths[eths=="British"] = "British (White)"
legend("topleft",legend=paste0("\t\t",c(eths,"Total")),col="transparent",inset=c(0.17,0),pch=NA,horiz=F,bty="n")
dev.off()

# By country of birth (means normalised by sd of each PC)
# NOTE: this is based on the same scripts as in pca-ethnic-backgroun-correlation.R but as a function in auxFunctions.R

cob =  get.place.of.birth(outTable)
eth2 = ethnicity2pop(outTable$Ethnic.background)
cob2 = cob
tab= table(cob)
minSamples=20
tooSmall = names(tab[tab<minSamples])
cob2[cob%in%tooSmall] = NA

print(paste0(sum(cob%in%tooSmall)," individuals removed because there is fewer than ",minSamples," individuals with their birth country. ",100*sum(cob%in%tooSmall)/length(cob),"% of data."))

####### Takes about 5mins to run
pcsByCob = cobByPClm(PCs,cob2,eth2)
#######

cobLMnormMean = pcsByCob[[2]]
cobLMnormMean2 = pcsByCob[[1]] # excluding those with pval<signif
treeOrder = pcsByCob[[8]]
Legend = pcsByCob[[4]]
colblindset= c("#CC79A7","white","#0072B2")
signif = pcsByCob[[6]]
pvals = pcsByCob[[7]]

cobLMnormMean3 = cobLMnormMean # set more relaxed pval threshold = 0.05/nPCs
cobLMnormMean3[pvals>=signif] = 0


toPlot = t(cobLMnormMean3[treeOrder$order,])
capValue = mean(abs(toPlot[toPlot!=0])) + 2*sd(abs(toPlot[toPlot!=0]))
#capValue = quantile(abs(toPlot[toPlot!=0]),0.95)
#capValue = 0 + 2*sd(abs(toPlot[toPlot!=0]))
capValue=6.2
png("plots/test.png")
hist(toPlot,breaks=50)
dev.off()

plotMixtureHeat(toPlot,filename=paste0('plots/',releaseSampleQCPrefix,'-PCA-COBsdNormalisedMeans.png'),cap=T,capValue=capValue,colourSet = colblindset,
title="Mean PC score by country of birth",xlab="PC",ylab=NA,colLabels=colnames(toPlot),rowLabels=1:nPCs,scaleTitle="sd-scaled mean",Legend=Legend,plotPoints=T,
height=2000,width=1500,res=150,Cex=1,y.cex=0.7,ylabMar=10,scaleWidth=0.1)

plotMixtureHeat(toPlot,filename=paste0('plots/',releaseSampleQCPrefix,'-PCA-COBsdNormalisedMeans.pdf'),cap=T,capValue=capValue,colourSet = colblindset,
title="Mean PC score by country of birth",xlab="PC",ylab=NA,colLabels=colnames(toPlot),rowLabels=1:nPCs,scaleTitle="sd-scaled mean",Legend=Legend,plotPoints=T,
height=2000/150,width=1500/150,Cex=1,y.cex=0.7,ylabMar=10,scaleWidth=0.1)


# without blanking out
toPlot = t(cobLMnormMean[treeOrder$order,])
capValue = mean(abs(toPlot[toPlot!=0])) + 2*sd(abs(toPlot[toPlot!=0]))
capValue = quantile(abs(toPlot),0.99)

#png("plots/test2.png")
#hist(toPlot,breaks=50)
#dev.off()

plotMixtureHeat(toPlot,filename=paste0('plots/',releaseSampleQCPrefix,'-PCA-COBsdNormalisedMeans-noLM.pdf'),cap=T,capValue=capValue,colourSet = colblindset,
title="Mean PC score by country of birth",xlab="PC",ylab=NA,colLabels=colnames(toPlot),rowLabels=1:nPCs,scaleTitle="sd-scaled mean",Legend=Legend,plotPoints=T,
height=2000/150,width=1500/150,Cex=1,y.cex=0.7,ylabMar=10,scaleWidth=0.1)

# Legend for the most common ethnicities

pdf(paste0('plots/',releaseSampleQCPrefix,'-PCA-COBsdNormalisedMeans-LEGEND.pdf'),bg="transparent",width=1500/150,height=1500/150)
plot.new()

eths2 = ethnicities[ethnicityOrder][ethnicities[ethnicityOrder]%in%unique(Legend$Factor)]  # only include those that are in the transformed ethnic groupings
legend("topright",legend=eths2,col=ethnicity2col[eths2],pch=ethnicity2char[eths2],pt.lwd=2,horiz=F,bty="n",title="Ethnic background")
dev.off()


#### Plot the eigen values (see pipeline.sh)
fastPCAout = paste0(baseSampleQCDir,"/data/PCA/b1__b11-b001__b095-autosome-sampleqc-fastpca-highquality-round2-coolibah.evecs")

evalues = t(read.table(fastPCAout,header=FALSE,nrow=1,comment.char="%")[,-1])[,1]

pdf(paste0('plots/',releaseSampleQCPrefix,'-PCA-EigenValues.pdf'),bg="transparent",width=1800/150,height=1500/150)
barplot(evalues,xlab="PC",ylab="Eigenvalue",col="gray35",border="lightgray",names.arg=1:40)
dev.off()

pdf(paste0('plots/',releaseSampleQCPrefix,'-PCA-EigenValues-fractions.pdf'),bg="transparent",width=1800/150,height=1500/150)
b=barplot(evalues/sum(evalues),xlab="PC",ylab="Fraction of sum of all 40 eigenvalues",col="gray35",border="lightgray",names.arg=1:40,main="Eigenvalues for 40 PCs as a fraction of total",ylim=c(0,0.7),yaxt="n")
axis(2,las=2)
text(x=b[1],y=evalues[1]/sum(evalues)+0.01,labels=round(evalues[1],0),xpd=NA)
text(x=b[40],y=evalues[40]/sum(evalues)+0.01,labels=round(evalues[40],0),xpd=NA)
text(x =(b[21]+b[20])/2,y=0.7,labels="Absolute values for PCs 1 and 40 are shown above bars",xpd=NA)
dev.off()

# make a text file
evalText = cbind(1:40,evalues)
colnames(evalText) = c("PC","Eigenvalue (fastPCA)")

write.table(evalText,file=paste0(releaseSampleQCPrefix,'-PCA-EigenValues.txt'),row.names=FALSE,col.names=TRUE,quote=FALSE,sep="\t")



#################################
# White British ancestry group
#################################

#wbColour = getColBlindCol("b")
wbColour = "cyan3"

wb = outTable$in.white.British.ancestry.subset==1
#Colors = ethnicity2col[pop]
colorsWB = Colors
colorsWB[wb] = wbColour
colorsWB[pop!="British"] = "darkgray"
    
Order = c(which(colorsWB=="darkgray"),which(colorsWB==ethnicity2col["British"]),which(colorsWB==wbColour))

#Order = sample(Order,2000,replace=FALSE)

png(paste0('plots/',releaseSampleQCPrefix,'-WhiteBritish-PCA-%02d.png'),bg="transparent",width=3*1500,height=3*1500,res=450)
par(cex.lab=1.5,mar=c(5.1,5.1,3,2))
for (pc in 1:6){
    
    if(pc%%2==0) next

    print(paste0('Plotting PCs',pc,' and ',pc + 1))

    x = PCs[[paste0("PC",pc)]]
    y = PCs[[paste0("PC",pc+1)]]

    plot(x[Order],y[Order],xlab=paste0('PC ',pc),ylab=paste0('PC ',pc+1),
         col=colorsWB[Order],pch=Chars[Order])#,axes=FALSE)    
#    axis(1,cex.lab=1.3)
#    axis(2,cex.lab=1.3)

}

dev.off()

# WB legend
pdf(paste0('plots/',releaseSampleQCPrefix,'-WhiteBritish-PCA-LEGEND.pdf'),bg="transparent",width=1500/150,height=1500/150)
plot.new()
legend("topleft",legend=c("In white British ancestry subset","Self-reported ethnic background British","Other ethnic background"),col=c(wbColour,ethnicity2col["British"],"darkgray"),pch=c(ethnicity2char[c("British","British")],1),pt.lwd=2,horiz=F,bty="n")
dev.off()




#################################
# Heterozygosity and missing rates
#################################
# NOTE: uses the same legend as for PCA

eth = outTable$Ethnic.background
pop = ethnicity2pop(eth)

Colors = ethnicity2col[pop]
Chars = ethnicity2char[pop]
Order = order.by.number.occurrences(pop)

ylims = c( min(outTable$heterozygosity),max(outTable$heterozygosity))
xlims = c(0.0001,max(outTable$sample.qc.missing.rate))
    
x = outTable$sample.qc.missing.rate
y= outTable$heterozygosity

myScale = getLogitTicks(range=c(round(xlims[1],4),round(xlims[2],2)),stepSize=0.2,nticks=10)

#Order = sample(Order,100,replace=FALSE)

pdf(paste0('plots/',releaseSampleQCPrefix,'-het-missing-Eth.pdf'),bg="transparent",width=3*1500/450,height=3*1500/450)
#png(paste0('plots/',releaseSampleQCPrefix,'-het-missing-Eth.png'),bg="transparent",width=3*1500,height=3*1500,res=450)
par(cex.lab=1.5,mar=c(5.1,5.1,3,2),cex.main=1.5,cex.axis=1.2)

plot(logit(x[Order]),y[Order],ylim=ylims,xlim=logit(xlims),col=Colors[Order],pch=Chars[Order],xaxt="n",xlab="Missing rate",ylab="Heterozygosity",main="Raw heterozygosity")

myLabels = round(myScale[[1]],5) #,get10power2(myScale[[1]],minPower=-1)
axis(1,at = logit(myScale[[1]]),labels=myLabels,cex=0.7,lwd=0,lwd.ticks=1)
axis(1,at = logit(myScale[[2]]),labels=NA,cex=0.7,tcl=-0.2,lwd=0,lwd.ticks=0.7)

dev.off()


y= outTable$heterozygosity.pc.corrected

pdf(paste0('plots/',releaseSampleQCPrefix,'-hetCorrected-missing-Eth.pdf'),bg="transparent",width=3*1500/450,height=3*1500/450)
#png(paste0('plots/',releaseSampleQCPrefix,'-hetCorrected-missing-Eth.png'),bg="transparent",width=3*1500,height=3*1500,res=450)

par(cex.lab=1.5,mar=c(5.1,5.1,3,2),cex.main=1.5,cex.axis=1.2)

plot(logit(x[Order]),y[Order],ylim=ylims,xlim=logit(xlims),col=Colors[Order],pch=Chars[Order],xaxt="n",xlab="Missing rate",ylab="PC-corrected heterozygosity",main="PC-corrected heterozygosity")
myLabels = round(myScale[[1]],5) #,get10power2(myScale[[1]],minPower=-1)
axis(1,at = logit(myScale[[1]]),labels=myLabels,cex=0.7,lwd=0,lwd.ticks=1)
axis(1,at = logit(myScale[[2]]),labels=NA,cex=0.7,tcl=-0.2,lwd=0,lwd.ticks=0.7)

dev.off()



y= outTable$heterozygosity.pc.corrected

pdf(paste0('plots/',releaseSampleQCPrefix,'-hetCorrected-missing-Outliers.pdf'),bg="transparent",width=3*1500/450,height=3*1500/450)
#png(paste0('plots/',releaseSampleQCPrefix,'-hetCorrected-missing-Outliers.png'),bg="transparent",width=3*1500,height=3*1500,res=450)

par(cex.lab=1.5,mar=c(5.1,5.1,3,2),cex.main=1.5,cex.axis=1.2)

cols2 = rep("#140019FF",length(y)); cols2[outTable$het.missing.outliers==1] = "red"
Order = order.by.number.occurrences(cols2)

plot(logit(x[Order]),y[Order],ylim=ylims,xlim=logit(xlims),col=cols2[Order],pch=Chars[Order],xaxt="n",xlab="Missing rate",ylab="PC-corrected heterozygosity",main=paste0(sum(outTable$het.missing.outliers==1)," outliers"))

myLabels = round(myScale[[1]],5) #,get10power2(myScale[[1]],minPower=-1)
axis(1,at = logit(myScale[[1]]),labels=myLabels,cex=0.7,lwd=0,lwd.ticks=1)
axis(1,at = logit(myScale[[2]]),labels=NA,cex=0.7,tcl=-0.2,lwd=0,lwd.ticks=0.7)

segments(x0=logit(0.05),y0=par()$usr[3],y1=par()$usr[4]+diff(ylims)/70,col="blue",lwd=1.2,lty=5,xpd=NA)

text(x=logit(0.05),y=par()$usr[4],labels=0.05,xpd=NA,pos=3,offset=0.8)

dev.off()



## plot each ethnicity separately
png(paste0('plots/',releaseSampleQCPrefix,"-correctedHetbyMissing-byEthnicity.png"),width=3*2000,height=3*2000,res=450)
par(mfrow=c(4,4))

ylims= c( min(outTable$heterozygosity.pc.corrected), max(outTable$heterozygosity.pc.corrected) )
xlims= logit(range(outTable$sample.qc.missing.rate))

thePops = ethnicities[ethnicityOrder]
thePops = thePops[thePops%in%pop]
for(p in thePops){
    
    print(p)
    these = pop==p
    x = logit(outTable$sample.qc.missing.rate[these])
    y = outTable$heterozygosity.pc.corrected[these]
    
    plot(x,y,ylab="PC-corrected heterozygosity" ,xlab="logit( missing rate )",col=Colors[these],pch=Chars[these],
         main=paste0(p," (",sum(these),")" ) ,ylim=ylims ,xlim=xlims)
    abline(mean(y),0,lty=3)
}

dev.off()


## box-plot of each ethnicity

png(paste0("plots/",releaseSampleQCPrefix,"-correctedHetbyEthnicity-boxplot.png"),bg="transparent",width=1200,height=1200,res=200)
par(mar=c(12,5,4,1),cex=0.8)

y = outTable$heterozygosity.pc.corrected
pop2 = factor(pop,levels=ethnicities[ethnicityOrder][ethnicities[ethnicityOrder]%in%pop] )

boxplot(y~pop2,ylim=range(y),las=2,outline=F,main="",border=NA,ylab="PC-corrected heterozygosity")

for( i in 1:length(levels(pop2))){    
    stripchart(y[pop2==levels(pop2)[i]], at = i, vertical = TRUE,jitter = 0.25, cex=0.8,
               add = TRUE, method = "jitter",pch = ethnicity2char[levels(pop2)[i]],axes=FALSE,col = add.alpha(ethnicity2col[levels(pop2)[i]],0.4))
}

boxplot(y~pop2,ylim=range(y),las=2,outline=F,main="",add=TRUE)

abline(h=mean(y),lty=3,col="black")

dev.off()




#################################
# SNP Minor allele frequency (after all QC)
#################################

#myBinCols = c("orange1","red4","purple","blue","green4")
#myBinCols =getColBlindCol(rev(c("b","g","o","v","r")))
#myBinCols = rev(viridis_pal()(5))
myBinCols = c("#FDE725FF","#21908CFF","#440154FF","#5DC863FF","#3B528BFF") # viridis5 reordered
myBinClasses = c("Very very rare","Very rare","Rare","Low frequency","Common")

# define maf bins
mafBins = c(0,1/10000,1/1000,1/100,5/100,Inf)
names(mafBins) = paste0("[",paste(sprintf("%g",mafBins[1:(length(mafBins)-1)]),sprintf("%g",mafBins[2:length(mafBins)]),sep="-"),")")
names(mafBins)[length(mafBins)-1] = paste0("[",mafBins[length(mafBins)-1],"-")

mafBins2 = c(0,1/1000,1/100,5/100,Inf)
names(mafBins2) = paste0("[",paste(sprintf("%g",mafBins2[1:(length(mafBins2)-1)]),sprintf("%g",mafBins2[2:length(mafBins2)]),sep="-"),")")
names(mafBins2)[length(mafBins2)-1] = paste0("[",mafBins2[length(mafBins2)-1],"-")


# define mac bins
macBins = c(0,10,100,1000,10000,Inf)
names(macBins) = paste0("[",paste(macBins[1:(length(macBins)-1)],macBins[2:length(macBins)],sep="-"),")")
names(macBins)[length(macBins)-1] = paste0("[",macBins[length(macBins)-1],"-")



# Read in frequencies: computed in QC-Scripts/Sample-QC/InterimComparison/compute-frequencies.sh
freqs = read.genotyped.maf( snpFrequencyData= "/well/ukbiobank/qcoutput.V2_QCed.sample-QC/data/Combined/V2_QCed.export.UKBiLEVEAX_b1-b11.Batch_b001_b095.chr" )

print(range(freqs$MAF) )
print( sum(is.na(freqs$MAF)))
print(range(freqs$MAC) )
print( sum(is.na(freqs$MAC)))

# Classify SNPs based on maf in released data
binsMaf = getMafBins(freqs$MAF,mafBins=mafBins)
Bins = factor(binsMaf)
levels(Bins) = names(mafBins)[as.numeric(levels(Bins))]
# label monomorphics separately
bins2 = binsMaf; bins2[freqs$MAF==0] = 0
Bins2 = factor(bins2)
#Bins
#    [0,1e-04) [1e-04,0.001)  [0.001,0.01)   [0.01,0.05)         [0.05 
#        49622         26212         55176        283821        390595 

# plot maf histogram
binSize = 0.01
Breaks=seq(0,0.5,by=binSize)
histCols = unlist( sapply(1:(length(mafBins)-1),function(i) rep(myBinCols[i],sum((Breaks>=mafBins[i])&(Breaks<mafBins[i+1])) ) ) )
histCols[histCols==myBinCols[1]]=myBinCols[2]


pdf(paste0("plots/",releaseSampleQCPrefix,"-maf-hist.pdf"),width=1000/150,height=1000/150,bg="transparent")
par(lwd=0.5)
hist(freqs$MAF,breaks=Breaks,ylim=c(0,140000),xlab="Minor allele frequency (MAF) in UK Biobank",ylab="Number of markers (1000s)",col="gray35",border="lightgray",main=paste0("Minor allele frequencies of ",dim(freqs)[1]," markers in UK Biobank data"),
cex=2,xlim=c(0,0.5),yaxt="n")
axis(2,at=seq(0,140000,by=20000),labels=seq(0,140000,by=20000)/1000,las=2)
dev.off()


# rare < 0.01 histogram
binSize = 0.0001
Breaks=seq(0,0.5,by=binSize)
histCols = unlist( sapply(1:(length(mafBins)-1),function(i) rep(myBinCols[i],sum((Breaks>=mafBins[i])&(Breaks<mafBins[i+1])) ) ) )

png(paste0("plots/",releaseSampleQCPrefix,"-maf-hist-rare.png"),width=1000,height=1000,res=150,bg="transparent")
par(lwd=0.5)
hist(freqs$MAF,breaks=Breaks,xlab="Minor allele frequency (MAF) in UK Biobank",ylab="Number of markers",col=histCols,border="white",main=NA,
cex=2,xlim=c(0,0.01))
dev.off()

# rare barplot of allele counts rather than frequencies! Subset by maf < 0.01
binsMac = getMafBins(freqs$MAC,mafBins=macBins,incZero=TRUE)
Bins = factor(binsMac)
levels(Bins) = gsub(",","-",c(0,names(macBins)[as.numeric(levels(Bins))]))
levels(Bins)[2] = gsub('[0','[1',levels(Bins)[2],fixed=TRUE)

#png(paste0("plots/",releaseSampleQCPrefix,"-mac-barplot-rare.png"),width=1000,height=1000,res=150,bg="transparent")
pdf(paste0("plots/",releaseSampleQCPrefix,"-mac-barplot-rare.pdf"),width=1000/150,height=1000/150,bg="transparent")
par(cex=2,mgp=c(4,0.4,0),mar=c(6,3,2,2),cex.lab=0.8,cex.axis=0.6)
barplot(table(Bins[freqs$MAF < 0.01])[1:5],ylim=c(0,60000),space=0.1,xlab=NA,ylab=NA,
col=myBinCols[3],border=NA,main=NA,xpd=NA,cex.names=0.6,tcl=-0.25,las=2,yaxt="n")
axis(2,at=seq(0,60000,by=10000),labels=seq(0,60000,by=10000)/1000,tcl=-0.25,las=2)
title(ylab="Number of markers (1000s)",line=1.5,xpd=NA)
title(xlab="Minor allele count (MAC)",line=3,xpd=NA)
dev.off()
# without brackets in the ranges.
pdf(paste0("plots/",releaseSampleQCPrefix,"-mac-barplot-rare-nobrackets.pdf"),width=1000/150,height=1000/150,bg="transparent")
par(cex=2,mgp=c(4,0.4,0),mar=c(6,3,2,2),cex.lab=0.8,cex.axis=0.6)
barplot(table(Bins[freqs$MAF < 0.01])[1:5],names =gsub("\\[|\\)","",levels(Bins)[1:5]),ylim=c(0,60000),space=0.1,xlab=NA,ylab=NA,
col=myBinCols[3],border=NA,main=NA,xpd=NA,cex.names=0.6,tcl=-0.25,las=2,yaxt="n")
axis(2,at=seq(0,60000,by=10000),labels=seq(0,60000,by=10000)/1000,tcl=-0.25,las=2)
title(ylab="Number of markers (1000s)",line=1.5,xpd=NA)
title(xlab="Minor allele count (MAC)",line=3,xpd=NA)
dev.off()


# rare barplot of frequencies rather than allele counts
binsMaf = getMafBins(freqs$MAF,mafBins=mafBins,incZero=TRUE)
Bins = factor(binsMaf)
levels(Bins) = gsub(","," - ",c(0,names(mafBins)[as.numeric(levels(Bins))]))
levels(Bins)[2] = gsub('[0','(0',levels(Bins)[2],fixed=TRUE)

                                        #png(paste0("plots/",releaseSampleQCPrefix,"-maf-barplot-rare.png"),width=1000,height=1000,res=150,bg="transparent")
pdf(paste0("plots/",releaseSampleQCPrefix,"-maf-barplot-rare.pdf"),width=1000/150,height=1000/150,bg="transparent")
par(cex=2,mgp=c(4,0.4,0),mar=c(6,3,2,2),cex.lab=0.8,cex.axis=0.6)
barplot(table(Bins)[1:4],space=0.1,ylab=NA,xlab=NA,col=myBinCols[3],border=NA,main=NA,xpd=NA,cex.names=0.6,tcl=-0.25,ylim=c(0,60000),las=2,yaxt="n")
axis(2,at=seq(0,60000,by=10000),labels=seq(0,60000,by=10000)/1000,tcl=-0.25,las=2)
title(ylab="Number of markers (1000s)",line=1.5,xpd=NA)
title(xlab="MAF",line=3.5,xpd=NA)
dev.off()


#################################
# SNP Failure rates (oxford qc)
#################################

batches = all.batches()

# Batch sizes (final release data)
batchSizes = table(outTable$Batch)


# SNPs in V2_QCd from Affymetrix
ps2snpBL = rbind(ukbileve.ps2snp("autosome"),ukbileve.ps2snp("sexchrom"))
ps2snpBB = rbind(ukbiobank.ps2snp("autosome"),ukbiobank.ps2snp("sexchrom"))    
ps2snpBoth = ps2snpBB[ps2snpBB$AffySNPID%in%intersect(ps2snpBB$AffySNPID,ps2snpBL$AffySNPID),]
ps2snpUnion = unique(rbind(ps2snpBB,ps2snpBL))
ps2snpBLonly = ps2snpBL[!ps2snpBL$AffySNPID%in%intersect(ps2snpBB$AffySNPID,ps2snpBL$AffySNPID),]
ps2snpBBonly = ps2snpBB[!ps2snpBB$AffySNPID%in%intersect(ps2snpBB$AffySNPID,ps2snpBL$AffySNPID),]

# NOTE: these are the numbers of AffyQC, not after we have done ours!
nSNPsBL = dim(ps2snpBL)[1]
nSNPsBB = dim(ps2snpBB)[1]
nSNPsBLonly = dim(ps2snpBLonly)[1]
nSNPsBBonly = dim(ps2snpBBonly)[1]
nSNPsBoth = dim(ps2snpBoth)[1]
    
# Read in oxford SNP QC files
snpFailByBatchFile = "/well/ukbiobank/expt/V2_QCed.SNP-QC/data/SNP-QC_summary/V2_QCed.batch_effect.plate_effect.hwe.malefemale.Affy-SNPolisher-QC.per-batch.txt"
sbfail = read.table(snpFailByBatchFile,header=TRUE,stringsAsFactors=FALSE)

snpQCFile = "/well/ukbiobank/expt/V2_QCed.export/data/export_SNP-QC/V2_QCed.export_SNP-QC.v3.txt"
snpqc = read.table(snpQCFile,header=TRUE,stringsAsFactors=FALSE,colClasses=c(rep("character",8),rep("numeric",107),rep("NULL",44)) ) # takes a while to read! 800000 x 108

 # unique failures per batch
snpFailuniqueBatch = "/well/ukbiobank/expt/V2_QCed.write_up/data/V2_QCed.SNP-QC.autosome.sexchrom.all_tests.fails_per_batch.txt"
sbfailall =  read.table(snpFailuniqueBatch,header=FALSE,stringsAsFactors=FALSE)


##########
# Classify snps

snpqcIndex = match(snpqc$rs_id,freqs$SNP)
snpqcMaf = freqs$MAF[snpqcIndex]
snpqcMac = freqs$MAC[snpqcIndex]

snpqcMafBin = getMafBins(snpqcMaf,mafBins)
snpqcMafBin = factor(snpqcMafBin)
levels(snpqcMafBin) = names(mafBins)[as.numeric(levels(snpqcMafBin))]
levels(snpqcMafBin)[length(levels(snpqcMafBin))] = paste0(levels(snpqcMafBin)[length(levels(snpqcMafBin))],"0.5)")

snpqcMafBin2 = getMafBins(snpqcMaf,mafBins2)
snpqcMafBin2 = factor(snpqcMafBin2)
levels(snpqcMafBin2) = names(mafBins2)[as.numeric(levels(snpqcMafBin2))]
levels(snpqcMafBin2)[length(levels(snpqcMafBin2))] = paste0(levels(snpqcMafBin2)[length(levels(snpqcMafBin2))],"0.5)")

snpqcNbatches = rowSums(snpqc[,grep("_qc",colnames(snpqc))]==0)

batchBins = c(0,1,2,4,8,16,32,64,max(snpqcNbatches)+1 ,Inf)
names(batchBins) = paste0(paste(batchBins[1:(length(batchBins)-1)],batchBins[2:length(batchBins)]-1,sep="-"),"")
names(batchBins)[1:2] = batchBins[1:2]
batchBins = batchBins[-length(batchBins)]
    
snpqcNbatchesBin = getMafBins(snpqcNbatches,batchBins)
snpqcNbatchesBin = factor(snpqcNbatchesBin)
levels(snpqcNbatchesBin) = c(names(batchBins)[as.numeric(levels(snpqcNbatchesBin))])


# plot maf x n-batches

png(paste0("plots/",releaseSampleQCPrefix,"-snpFail-barplot-nbatches-prop.png"),width=1000,height=1000,res=150,bg="transparent")
barplot(table(snpqcNbatches)/length(snpqcNbatches),space=0.1,xlab="Number of batches failed QC",ylab="Proportion of markers in MAF range")
dev.off()

png(paste0("plots/",releaseSampleQCPrefix,"-snpFail-barplot-nbatches.png"),width=1000,height=1000,res=150,bg="transparent")
barplot(table(snpqcNbatches),space=0.1,xlab="Number of batches a marker failed QC",ylab="Number of markers")
dev.off()


#myBinCols = c("#FDE725FF","#21908CFF","#440154FF","#5DC863FF","#3B528BFF") # viridis5 reordered

snpqcTabMaf = table(snpqcMafBin,snpqcNbatchesBin)
snpqcTabMafProp = snpqcTabMaf/rowSums(snpqcTabMaf)

legNames = paste0(myBinClasses,":  ",levels(snpqcMafBin))

#png(paste0("plots/",releaseSampleQCPrefix,"-snpFail-barplot-nbatches-byMaf-prop.png"),width=1000,height=1000,res=150,bg="transparent")
pdf(paste0("plots/",releaseSampleQCPrefix,"-snpFail-barplot-nbatches-byMaf-prop.pdf"),widt=1000/150,height=1000/150,bg="transparent")
par(lwd=0.5)
barplot(snpqcTabMafProp,beside=TRUE,xlab=NA,ylab="Proportion of markers in MAF range",col=myBinCols,ylim=c(0,1),
border="lightgray",main=paste0("Marker-based QC failure rates for different MAF ranges"),cex.names=0.8,yaxt="n", mgp=c(3,0.5,0))
axis(2,at=seq(0,1,by=0.2),las=2)
title(xlab="Number of batches in which a marker failed QC",line=2)
legend(x=20,y=0.8,legend=legNames,col=myBinCols,pch=15,bty="n",title="MAF ranges",cex=1)
dev.off()

#png(paste0("plots/",releaseSampleQCPrefix,"-snpFail-barplot-nbatches-byMaf.png"),width=1000,height=1000,res=150,bg="transparent")
pdf(paste0("plots/",releaseSampleQCPrefix,"-snpFail-barplot-nbatches-byMaf.pdf"),width=1000/150,height=1000/150,bg="transparent")
par(lwd=0.5)
barplot(snpqcTabMaf,beside=TRUE,xlab=NA,ylab="Number of markers (1000s)",col=myBinCols,ylim=c(0,400000),
border="lightgray",main=paste0("Marker-based QC failure rates for different MAF ranges"),yaxt="n",cex.names=0.8, mgp=c(3,0.5,0))
axis(2,at=seq(0,400000,by=50000),labels=seq(0,400000,by=50000)/1000,las=2)
title(xlab="Number of batches in which a marker failed QC",line=2)
legend(x=20,y=0.8,legend=legNames,col=myBinCols,pch=15,bty="n",title="MAF ranges",cex=1)
dev.off()


# proportions without very rare
snpqcTabMaf2 = table(snpqcMafBin2,snpqcNbatchesBin)
snpqcTabMafProp2 = snpqcTabMaf2/rowSums(snpqcTabMaf2)

#> snpqcTabMafProp2
#              snpqcNbatchesBin
#snpqcMafBin2              0            1          2-3          4-7         8-15
#  [0-0.001)    8.372234e-01 7.687845e-02 4.631168e-02 2.547670e-02 1.329219e-02
#  [0.001-0.01) 8.816152e-01 6.631506e-02 3.200667e-02 1.241482e-02 6.089604e-03
#  [0.01-0.05)  9.227823e-01 3.920429e-02 2.119646e-02 1.052776e-02 5.292068e-03
#  [0.05-0.5)   9.720555e-01 1.184347e-02 6.515700e-03 4.498265e-03 4.173120e-03
#              snpqcNbatchesBin
#snpqcMafBin2          16-31        32-63       64-105
#  [0-0.001)    8.043885e-04 0.000000e+00 1.318670e-05
#  [0.001-0.01) 1.468030e-03 3.624764e-05 5.437147e-05
#  [0.01-0.05)  7.222862e-04 1.620740e-04 1.127471e-04
#[0.05-0.5)   5.990860e-04 1.331302e-04 1.817740e-04

legNames2 = paste0(myBinClasses[-1],":  ",levels(snpqcMafBin2))

#png(paste0("plots/",releaseSampleQCPrefix,"-snpFail-barplot-nbatches-byMaf2-prop.png"),width=1000,height=1000,res=150,bg="transparent")
pdf(paste0("plots/",releaseSampleQCPrefix,"-snpFail-barplot-nbatches-byMaf2-prop.pdf"),width=1000/150,height=1000/150,bg="transparent")
barplot(snpqcTabMafProp2,beside=TRUE,xlab="Number of batches in which a marker failed QC",ylab="Proportion of markers in MAF range",col=myBinCols[-1],border="lightgray")
legend("topright",legend=legNames2,col=myBinCols[-1],pch=15,bty="n",title="MAF ranges")
dev.off()


pdf(paste0("plots/",releaseSampleQCPrefix,"-snpFail-barplot-nbatches-byMaf2-prop.pdf"),widt=1000/150,height=1000/150,bg="transparent")
par(lwd=0.5)
barplot(snpqcTabMafProp2,beside=TRUE,xlab=NA,ylab="Proportion of markers in MAF range",col=myBinCols[-1],ylim=c(0,1),
border="lightgray",main=paste0("Marker-based QC failure rates for different MAF ranges"),cex.names=0.8,yaxt="n", mgp=c(3,0.5,0))
axis(2,at=seq(0,1,by=0.2),las=2)
title(xlab="Number of batches in which a marker failed QC",line=2)
legend(x=20,y=0.8,legend=legNames2,col=myBinCols[-1],pch=15,bty="n",title="MAF ranges",cex=1)
dev.off()

#png(paste0("plots/",releaseSampleQCPrefix,"-snpFail-barplot-nbatches-byMaf.png"),width=1000,height=1000,res=150,bg="transparent")
pdf(paste0("plots/",releaseSampleQCPrefix,"-snpFail-barplot-nbatches-byMaf2.pdf"),width=1000/150,height=1000/150,bg="transparent")
par(lwd=0.5)
barplot(snpqcTabMaf2,beside=TRUE,xlab=NA,ylab="Number of markers (1000s)",col=myBinCols[-1],ylim=c(0,400000),
border="lightgray",main=paste0("Marker-based QC failure rates for different MAF ranges"),yaxt="n",cex.names=0.8, mgp=c(3,0.5,0))
axis(2,at=seq(0,400000,by=50000),labels=seq(0,400000,by=50000)/1000,las=2)
title(xlab="Number of batches in which a marker failed QC",line=2)
legend(x=20,y=0.8,legend=legNames2,col=myBinCols[-1],pch=15,bty="n",title="MAF ranges",cex=1)
dev.off()




# How many snps fail each test in each batch?
# IMPORTANT NOTE: this is not enough information to know the number of unique snps that fail this test in at least one batch!

######################### THESE NUMBERS ARE FROM COLIN
discordanceFailsUKBB = 632
discordanceFailsUKBL = 622
discordanceFailsUniq = 652
arrayFails = 5417
#########################

# Summary of mean batch-level failures for each test
sbfail$array = arrayFails
sbfail$discordance = discordanceFailsUKBB
sbfail$discordance[sbfail$Batch%in%ukbileve.batches()] = discordanceFailsUKBL

summary = apply( sbfail[,-1],2, function(x) c(mean(x),sd(x) ) )

# Fraction of all calls that were affected by this (in the V2_QC data from Affy)
tests = colnames(summary)
snpsPerBatch = rep(NA,dim(sbfail)[1]);
snpsPerBatch[sbfail$Batch%in%ukbileve.batches()] = nSNPsBL
snpsPerBatch[sbfail$Batch%in%ukbiobank.batches()] = nSNPsBB
samplesPerBatchOriginal = origBatchSizes[sbfail$Batch] # NOTE: only max 67 samples different in a single batch after QC.

# sum( samplesperbatch * nfailedsnpsperbatch )/sum( samplesperbatch * snpsperbatch)
# Do the calculation in log space
callsTotalUKBL = 10^(log10(sum(samplesPerBatchOriginal[sbfail$Batch%in%ukbileve.batches()])) + log10(nSNPsBL))
callsTotalUKBB = 10^(log10(sum(samplesPerBatchOriginal[sbfail$Batch%in%ukbiobank.batches()])) + log10(nSNPsBB))
callsTotal = callsTotalUKBB+callsTotalUKBL

fractionFail = sapply(tests,function(i) sum(samplesPerBatchOriginal * sbfail[,i]/callsTotal))

# Total unique snps failing anything.
fractionFailAll =  sum(samplesPerBatchOriginal * sbfailall[,2]/callsTotal)
summary = cbind(summary,c(mean(sbfailall[,2]),sd(sbfailall[,2])))
colnames(summary)[ncol(summary)] = "Total"


# A summary table (mean counts rounded to nearest integer)
meanCounts = paste0(round(summary[1,],0)," (",round(summary[2,],0),")")
# special for array and discordance
meanCounts[colnames(summary)=="array"] = paste0(round(summary[1,colnames(summary)=="array"],0))
meanCounts[colnames(summary)=="discordance"] = paste0(discordanceFailsUKBL," (ukbl), ",discordanceFailsUKBB," (ukbb)")

testNames = c("1. Batch effect","2. Plate effect","3. Hardy-Weinburg disequilibrium","4. Sex effect","ThermoFisher Scientific cluster QC","5. Array effect","6. Discordance across controls","Total")
testFailsTable = cbind.data.frame(testNames,c(meanCounts),c(format(c(fractionFail,fractionFailAll),scientific=TRUE,digits=3)))

colnames(testFailsTable) = c("Test","Average number of SNPs failed per batch (sd) ","Fraction of all genotype calls affected")

write.table(testFailsTable[c(5,1:4,6:8),],file=paste0(releaseSampleQCPrefix,"-snpFail-tests-table.txt"),quote=FALSE,row.names=FALSE,col.names=TRUE,sep="\t")


# Histograms
png(paste0("plots/",releaseSampleQCPrefix,"-snpFail-hist-tests.png"),width=500,height=2000,res=150,bg="transparent")
par(mfrow=c(5,1),lwd=0.5)
for( i in tests ){
if( i == tests[1] ) h=hist( sbfail[,i] ,breaks=seq(0,max(sbfail[,tests])+50,50) ,main=i,col="darkgray",border="white") else hist( sbfail[,i] ,breaks=h$breaks,main=i,col="darkgray",border="white")
}
dev.off()



#################################
# SNP/SAMPLE missing rates (After all QC) <===== THIS IS THE CORRECT VERSION!!
#################################
colukbb = viridis_pal()(20)[4]
colukbl = viridis_pal()(20)[14]
colukbb = getColBlindCol("b")
colukbl = getColBlindCol("r")

####### Missing rates for SNPs 

# across all samples
lmissFile = paste0(GenotypesForReleaseFiles,".missing.lmiss")
lmiss = read.table(lmissFile,header=TRUE,stringsAsFactors=FALSE)

missFracSNPs = lmiss$F_MISS

png(paste0("plots/",releaseSampleQCPrefix,"-missing-rates-snps-all-samples.png"),width=1000,height=1000,res=150 )
par(lwd=0.5)
hist(missFracSNPs,breaks=100,xlab="Fraction of samples with missing call",ylab="Number of markers",main=paste0(length(missFracSNPs)," markers" ),col="darkgray",border="black",xlim=c(0,max(missFracSNPs)))
dev.off()

png(paste0("plots/",releaseSampleQCPrefix,"-missing-rates-logit-snps-all-samples.png"),width=1000,height=1000,res=150 )
par(lwd=0.5)
hist(logit(missFracSNPs),breaks=50,xlab="logit( Fraction of samples with missing call",ylab="Number of markers )",main=paste0(length(missFracSNPs)," markers" ),col="darkgray",border="black")
dev.off()

ukbbSnps = lmiss$SNP%in%ps2snpBBonly$dbSNPRSID
ukblSnps = lmiss$SNP%in%ps2snpBLonly$dbSNPRSID
bothSnps = lmiss$SNP%in%ps2snpBoth$dbSNPRSID


#png(paste0("plots/",releaseSampleQCPrefix,"-missing-rates-logit-snps-all-samples-splitArray.png"),width=1000,height=1000,res=150 ,bg="transparent")
pdf(paste0("plots/",releaseSampleQCPrefix,"-missing-rates-logit-snps-all-samples-splitArray.pdf"),width=1000/150,height=1000/150,bg="transparent")
par(lwd=0.5,mar=c(5.1 ,4.1 ,4.1 ,4))

h=hist(log10(missFracSNPs[bothSnps]),breaks=80,xlab="Missing rate",ylab="Number of markers (1000s)",border="lightgray",col="gray35",yaxt="n",xaxt="n",xlim=log10(c(3*10^(-5),1)),ylim=c(0,50000),main="Missing rates for markers")

myScale = getLogTicks(nticks=10,lims=c(10^par()$usr[1],1))
#sub = seq(1,length(myScale),5)
myLabels = get10power2(myScale[[1]],minPower=-1)
axis(1,at = log10(myScale[[1]]),labels=myLabels,cex=0.7,lwd=0,lwd.ticks=1)
axis(1,at = log10(myScale[[2]]),labels=NA,cex=0.7,tcl=-0.2,lwd=0,lwd.ticks=0.7)
axis(1,at = log10(myScale[[3]]),labels=NA,cex=0.7,lwd.ticks=0) # draw the axis line

axis(2,at=seq(0,50000,by=10000),labels=seq(0,50000,by=10000)/1000,las=2)

hist(log10(missFracSNPs[ukbbSnps]),breaks=h$breaks,border="lightgray",col=add.alpha(colukbb,0.6),add=TRUE)
hist(log10(missFracSNPs[ukblSnps]),breaks=h$breaks,border="lightgray",col=add.alpha(colukbl,0.6),add=TRUE)

legend("topleft",col=c("gray35",colukbb,colukbl),cex=0.9,pt.cex=1,
       legend=c(paste0("Markers on both arrays (",sum(bothSnps),")"),paste0("Markers on UK Biobank Axiom array only (",sum(ukbbSnps),")"),
paste0("Markers on UKBiLEVE Axiom array only (",sum(ukblSnps),")")),pch=15,bty="n",inset=c(0.02,-0.04),xpd=NA)
dev.off()


# boxplot by allele frequency bins

# only snps on both arrays
inBoth = freqs$SNP%in%c(ps2snpBoth$dbSNPRSID,ps2snpBoth$AffySNPID)

png(paste0("plots/",releaseSampleQCPrefix,"-missing-rates-snps-all-samples-by-MAF-boxplot.png"),width=1000,height=1000,res=150 )
par(lwd=0.5,mfrow=c(2,2))

if(i==2) hist(x,breaks=seq(0,1,0.01),xlab="Fraction of samples with missing call",main=paste0(length(missFracSNPs)," samples" ),col=My.add.alpha2(myBinCols[i-1],alpha=0.2),border="white",xlim=c(0,max(missFracSNPs)),freq=FALSE)

if(i!=2) hist(x,breaks=seq(0,1,0.01),col=My.add.alpha2(myBinCols[i-1],alpha=0.2),border="white",freq=FALSE)

}

dev.off()


####### Missing rates for individuals

# across all autosomes
imissFile = paste0(GenotypesForReleaseFiles,".chr1-22.imiss.txt")
imiss = read.table(imissFile,header=FALSE,stringsAsFactors=FALSE)

missFracSamples = imiss$V6

png(paste0("plots/",releaseSampleQCPrefix,"-missing-rates-samples-all-snps.png"),width=1000,height=1000,res=150,bg="transparent")
par(lwd=0.5)
hist(missFracSamples,breaks=100,xlab="Fraction of markers with missing call",ylab="Number of samples",main=paste0(length(missFracSamples)," samples" ),col="gray35",border="black",xlim=range(missFracSamples))
dev.off()

ukbbSamples = imiss$V1%in%outTable$PIID[outTable$Batch%in%ukbiobank.batches()]
ukblSamples = imiss$V1%in%outTable$PIID[outTable$Batch%in%ukbileve.batches()]

#png(paste0("plots/",releaseSampleQCPrefix,"-missing-rates-samples-all-snps-splitArray.png"),width=1000,height=1000,res=150 ,bg="transparent")
pdf(paste0("plots/",releaseSampleQCPrefix,"-missing-rates-samples-all-snps-splitArray.pdf"),width=1000/150,height=1000/150,bg="transparent")
par(lwd=0.3,mar=c(5.1 ,4.1 ,4.1 ,4))
Breaks = seq(0,0.13,by=0.001)
Breaks=80
h = hist(missFracSamples,breaks=Breaks,xlab="Missing rate",ylab="Number of samples (1000s)",main="Missing rates for samples",col="transparent",border=NA,yaxt="n",ylim=c(0,80000))#,border="lightgray",col="gray35")

axis(2,at=seq(0,80000,by=20000),labels=seq(0,80000,by=20000)/1000,las=2)

hist(missFracSamples[ukbbSamples],breaks=h$breaks,border="lightgray",col=add.alpha(colukbb,0.6),add=TRUE)
hist(missFracSamples[ukblSamples],breaks=h$breaks,border="lightgray",col=add.alpha(colukbl,0.6),add=TRUE)

legend("topright",col=c(colukbb,colukbl),cex=0.9,pt.cex=1,
       legend=c(paste0("Samples typed on UKBiobank Axiom array (",sum(ukbbSamples),")"),
paste0("Samples typed on UKBiLEVE Axiom array (",sum(ukblSamples),")")),pch=15,bty="n",inset=c(-0.005,0.15))
dev.off()


print(mean(missFracSamples))
# 0.03061163




#################################
# Table of number of samples/snps on each array before and after QC
#################################

nSnpsBeforeQC = c(nSNPsBLonly,nSNPsBBonly,nSNPsBoth) # after Affy qc, but before ours
nSamplesBeforeQC = c(nIndsOrigUKBL,nIndsOrigUKBB,0)  # after Affy qc, but before ours
nSnpsAfterQC = c(sum(ukblSnps),sum(ukbbSnps),sum(bothSnps)) # after oxford qc
nSamplesAfterQC = c(sum(ukblSamples),sum(ukbbSamples),0) # after oxford qc

qcCountsTab = rbind(nSnpsBeforeQC,nSamplesBeforeQC,nSnpsAfterQC,nSamplesAfterQC)
qcCountsTab2 = cbind(c("Before QC","","After QC",""),c("Number of markers","Number of samples","Number of markers","Number of samples"),qcCountsTab,rowSums(qcCountsTab))

colnames(qcCountsTab2) = c(" "," ","UK BiLEVE Array only","UK Bibank Array only","Both arrays","Total")

write.table(qcCountsTab2,file=paste0(releaseSampleQCPrefix,"-counts-beforeAndAfterQC-table.txt"),quote=FALSE,row.names=FALSE,col.names=TRUE,sep="\t")

xTab = xtable(qcCountsTab2, caption = NULL, label = NULL, align = NULL, display = NULL)
digits(xTab) <- xdigits(xTab)

#align(xTab) <- paste(c("|r|r|",rep("p{0.1\\textwidth}",dim(batchInfoTable)[2]-1),"|"),collapse="")

sink(file=paste0(releaseSampleQCPrefix,"-counts-beforeAndAfterQC-table.tex"))
print(xTab,include.rownames = FALSE,sanitize.colnames.function = bold)
sink()



######################################################################
# Clare's first go at this. snp-qc failures source defined in auxFunctions.R. <=== DO NOT USE!!

########## 
snpqcAut = read.SNPQC.files(type="autosome",justSNPs=FALSE)
snpqcSex = read.SNPQC.files(type="sexchrom",justSNPs=FALSE)
##########

nSNPs = rep(dim(ps2snpBB)[1],length(batches))
names(nSNPs) = batches
nSNPs[ukbileve.batches()] = dim(ps2snpBL)[1]

# Counts per test per batch
Counts = sapply(names(snpqc)[!sapply(snpqc,function(x) is.null(x))],function(y){
    print(y)
    test = rbind(snpqcAut[[y]],snpqcSex[[y]])
        
    if( !y %in% c("hweSNPs","arraySNPs","concordanceSNPs","imageSNPs") ){        
        nPerBatch = table(test[,1])   
        fracs = nPerBatch        
    }
    if(y=="imageSNPs") fracs = NULL
    if(y=="hweSNPs") fracs=NULL
    if(y %in% c("arraySNPs","concordanceSNPs") ) fracs=length(unique(test[,1]))
    out = fracs
    return(out)
},simplify=FALSE)


nSNPspertest = sapply(names(Counts), function(y){
    if( !y %in% c("hweSNPs","arraySNPs","concordanceSNPs","imageSNPs") ){        
        fracs = nSNPs[names(Counts[[y]])]
    }
    if(y=="imageSNPs") fracs = NULL
    if(y=="hweSNPs") fracs=NULL
    if(y=="arraySNPs")  fracs=dim(ps2snpBoth)[1]  # only the intersection of snps
    if(y=="concordanceSNPs") fracs=dim(ps2snpUnion)[1]  # the union of snps
    out = fracs
    return(out)

},simplify=FALSE)

Fracs = sapply(names(Counts), function(y){
    Counts[[y]]/nSNPspertest[[y]]
})

fracPerBatch = abind(Fracs,along=1,hier.names=TRUE)
                                        # nSNPs per batch
toPlot = cbind.data.frame(fracPerBatch,gsub("\\.Batch.*$|\\.UKB.*$","",names(fracPerBatch)))

png('plots/boxplot-fractionSNPsPerTest.png',width=1200,height=1000,res=150)
par(mar=c(10,10,2,2))
e=factor(toPlot[,2],levels=unique(toPlot[,2])[order(sapply(unique(toPlot[,2]),median))])
boxplot(toPlot[,1]~e,las=2,ylab="Fraction of markers failing")

dev.off()


# Print table
tabs = sapply(levels(e),function(x) c(mean(toPlot[toPlot[,2]==x,1]),sd(toPlot[toPlot[,2]==x,1])))
print("Fraction failing each test")
print(t(tabs))


# Fraction of all genotypes (per test) --> count number of samples per batch too
nGenotypesBL = log10(dim(ps2snpBL)[1]) + log10(sum(batchSizes[ukbileve.batches()]))
nGenotypesBB = log10(dim(ps2snpBB)[1]) + log10(sum(batchSizes[ukbiobank.batches()]))
nGenotypesTotal = 10^nGenotypesBL + 10^nGenotypesBB

# TOTAL GENOTYPE CALLS = Lukbiobank * Nukbiobank + Lukbileve * Nukbileve

print("Total genotype calls (accounting for array differences) ")
print(nGenotypesTotal)


totalSNPsAndSamplesExcluded = sapply(names(Counts),function(y){
    print(y)
    x = Counts[[y]]
    o = sum(x*batchSizes[names(x)]) # mulitple nSNPs failed by samples in each batch and sum
    if(y=="arraySNPs") o = 10^(log10(x)+log10(sum(batchSizes))) # all samples involved 
    if(y=="concordanceSNPs") {
        test = rbind(snpqcAut[[y]],snpqcSex[[y]])
        
        xbb = sum(unique(test$V1)%in%ps2snpBBonly$AffySNPID)
        bbOnly = sum(xbb*batchSizes[ukbiobank.batches()]) # count snpsxsamples only in ukbiobank batches
        xbl = sum(unique(test$V1)%in%ps2snpBLonly$AffySNPID)

        blOnly = sum(xbl*batchSizes[ukbiobank.batches()]) # count snpsxsamples only in ukbileve batches
        xboth = sum(unique(test$V1)%in%ps2snpBoth$AffySNPID)
        bothOnly = sum(xboth*batchSizes) # count snpsxsamples in both arrays
        o = bbOnly + blOnly + bothOnly
    }
    return(o)
})

fracOfAllGenotypes = totalSNPsAndSamplesExcluded/nGenotypesTotal
print("Fraction all all genotype calls set to missing")
print(cbind.data.frame(totalSNPsAndSamplesExcluded,fracOfAllGenotypes))


# Fraction of all genotypes (any test) --> count number of samples per batch too

CountsAnyTest = sapply(batches,function(b){
    print(b)
    fails = sapply(names(snpqcAut),function(test){
        #print(test)
        fs = rbind(snpqcAut[[test]],snpqcSex[[test]])
        if(test%in%c("arraySNPs","concordanceSNPs")) o = unique(fs[,1]) else o = unique(fs[fs[,1]==b,2])
        return(o)
    })
    fails = unique(unlist(fails)) # unique failed snps in this batch    
    if(b%in%ukbileve.batches()) totalSnps = length(fails[fails%in%ps2snpBL$AffySNPID])
    if(b%in%ukbiobank.batches()) totalSnps = length(fails[fails%in%ps2snpBB$AffySNPID])
    return(totalSnps)
})

print("Range of counts of snps failing any test in each batch.")
print( range(CountsAnyTest) )
print("Range of fraction of snps failing any test in each batch.")
print( range(CountsAnyTest/nSNPs[names(CountsAnyTest)]) )

totalSNPsAndSamplesExcludedAnyTest = sum( 10^(log10(CountsAnyTest) + log10(batchSizes[names(CountsAnyTest)])) ) # a whole batch is set to missing for each failed snp. Only snpsxsamples within the given array are counted.

print("Total number of genotype calls set to missing (any test)")
print(totalSNPsAndSamplesExcludedAnyTest)

print("Fraction number of genotype calls set to missing (any test)")
print(totalSNPsAndSamplesExcludedAnyTest/nGenotypesTotal)





#################################
# Concordance rates (description of data quality)
#################################

####### Concordance across duplicates from Relatedness/postking/plot-duplicate-concordance.R
#### Concordance is fraction of non-missing SNPs that are IBS2

load(paste0(baseSampleQCDir,"/QC-Scripts/Sample-QC/Relatedness/b1__b11-b001__b095-pair_batches.filtered-duplicates-twins-with-discordance.RData"),verbose=TRUE)

intended = dupeAnnot$Status..SM.=="Intended"
intendedPairs = c( paste0(dupeAnnot$Best_Array.x[intended],dupeAnnot$Best_Array.y[intended]),paste0(dupeAnnot$Best_Array.y[intended],dupeAnnot$Best_Array.x[intended]))

these=paste0(twinDupe$ID1,twinDupe$ID2)%in%intendedPairs

# twins as confirmed by uk biobank. Not all are in our kinship table. Why?
dupATw = dupeAnnot[dupeAnnot$Status..Ligia.=="Twins",]
ourTwins = kin2[kin2$class=="dupe/twins",]
# pairs where at least one of them does not appear in kin2
dupATw[(!dupATw$Best_Array.y%in%c(ourTwins$ID1,ourTwins$ID2)) | (!dupATw$Best_Array.x%in%c(ourTwins$ID1,ourTwins$ID2)),]
# odd pair in confirmed twins:
dupATw[(dupATw$eid.x%in%c(1848454,4038833))|(dupATw$eid.x%in%c(1848454,4038833)),]
ourTwins[ourTwins$ID2=="A550465-4195826-090714-385_H03",]

# odd pair in all duplicates:
dupeAnnot[(dupeAnnot$eid.x%in%c(1848454,4038833))|(dupeAnnot$eid.x%in%c(1848454,4038833)),]


meanIntendedDupes = mean(twinDupe$fracConcordance[these])
sdIntendedDupes = sd(twinDupe$fracConcordance[these])
minIntendedDupes = min(twinDupe$fracConcordance[these])

print(meanIntendedDupes) # 0.9987284
print(sdIntendedDupes) # 0.0009758464
print(minIntendedDupes) # 0.9938794

#png(paste0("plots/",releaseSampleQCPrefix,"-duplicates-intended-concordance.png"),width=1000,height=1000,res=150)
pdf(paste0("plots/",releaseSampleQCPrefix,"-duplicates-intended-concordance.pdf"),width=1000/150,height=1000/150)
par(lwd=0.5)
hist(100*twinDupe$fracConcordance[these],breaks=30,xlab="Percent of non-missing genotype calls which are identical",col="gray35",border="white",main=paste0("Concordance rates for ",dim(twinDupe[these,])[1]," pairs of Blind Spike Duplicates"),
cex=2,xlim=100*c(min(twinDupe$fracConcordance),1))
dev.off()

#################################
# Concordance rates PER SNP!  <===== NOT ACTUALLY USED
#################################

theSet = paste0(twinDupe$ID1[these],"..",twinDupe$ID2[these])

disconcordSNPs = sapply(theSet,function(x){
file = paste0(baseSampleQCDir,"/data/Relatedness/duplicateDiffs/b1__b11-b001__b095-pair_batches.filtered.genoDiffs.",x,".txt")
#print(x)
o = read.table(file,header=FALSE,stringsAsFactors=FALSE,colClasses="integer")
NA2 = o[o[,2]==2,1] # both have NA
NA1 = o[o[,2]==1,1] # one has NA
diffs = o[o[,2]==0,1] # markers are NA2
if( length(unique(o[,1]))!=nrow(o) ) print(paste0("CHECK ",x))

has1Allele2 = read.table(gsub(".txt",".allele2.txt",file),header=FALSE,stringsAsFactors=FALSE,colClasses="integer")[,1]

return(list("NA1"=NA1,"NA2"=NA2,"diffs"=diffs,"has1Allele2"=has1Allele2))
},simplify=FALSE)

rawDupeGenotypes = '/well/ukbiobank/qcoutput.V2_QCed.sample-QC/data/Relatedness/b1__b11-b001__b095-pair_batches.filtered-duplicates-genotypes.traw'
genotypesHeader = read.table(rawDupeGenotypes,header=FALSE,stringsAsFactors=FALSE,nrow=1)[1,]
snpOrderForDiscord = read.table(rawDupeGenotypes,header=TRUE,stringsAsFactors=FALSE,colClasses=c(rep(NA,6),rep("NULL",length(genotypesHeader)-6)))

freqs = read.genotyped.maf()


####### Consider only autosomes.
index.freqs = match(snpOrderForDiscord$SNP,freqs$SNP)
snpOrderForDiscord$MAF = freqs$MAF[index.freqs]
snpOrderForDiscord$freqsA1 = freqs$A1[index.freqs]
snpOrderForDiscord$freqsA2 = freqs$A2[index.freqs]
snpOrderForDiscord$MinorAllele = freqs$MinorAllele[index.freqs]
snpOrderForDiscord$MinorAlleleName = snpOrderForDiscord$freqsA1
snpOrderForDiscord$MinorAlleleName[which(snpOrderForDiscord$MinorAllele==2)] = snpOrderForDiscord$freqsA2[which(snpOrderForDiscord$MinorAllele==2)]

# Classify SNPs based on maf in released data
binsMaf = getMafBins(snpOrderForDiscord$MAF,mafBins=mafBins)
Bins = factor(binsMaf)
levels(Bins) = names(mafBins)[as.numeric(levels(Bins))]
# label monomorphics separately
bins2 = binsMaf; bins2[snpOrderForDiscord$MAF==0] = 0
Bins2 = factor(bins2)
#Bins
#    [0,1e-04) [1e-04,0.001)  [0.001,0.01)   [0.01,0.05)         [0.05 
#        49622         26212         55176        283821        390595 

SNPconcordanceRates = sapply(levels(Bins),function(x){
print(x)
theRows = which(Bins==x)
d = sapply(disconcordSNPs,function(pair){
    totalMissing = sum( theRows %in% c(pair$NA1,pair$NA2) )
    totalDiff = sum( theRows %in% pair$diffs )
    return(c(totalMissing,totalDiff))
})
totalNonMissing = sum( length(theRows)-d[1,] )
totalDifferent = sum( d[2,] )
fractionDiscordant = totalDifferent/totalNonMissing

return(fractionDiscordant)

})
##### THE ANSWER of SNPconcordanceRates
#     [0-0.0001) [0.0001-0.001)   [0.001-0.01)    [0.01-0.05)         [0.05- 
#    8.976877e-05   1.835010e-04   5.298621e-04   1.165000e-03   1.622511e-03 

### Below not used
SNPconcordanceRatesMinorAllele = sapply(levels(Bins),function(x){
print(x)
theRows = which(Bins==x)
minorRows = snpOrderForDiscord$COUNTED == snpOrderForDiscord$MinorAllele
d = sapply(disconcordSNPs,function(pair){
    totalMissing = sum( theRows %in% c(pair$NA1,pair$NA2) )
    hasMinorAllele = theRows %in% pair$has1Allele2 
    totalDiff = sum( theRows %in% pair$diffs )
    return(c(totalMissing,totalDiff))
})
totalNonMissing = sum( length(theRows)-d[1,] )
totalDifferent = sum( d[2,] )
fractionDiscordant = totalDifferent/totalNonMissing

return(fractionDiscordant)

})


######################################################################
####### Concordance across interim release from InterimComparison/plot-comparison.R

load(paste0(baseSampleQCDir,"/QC-Scripts/Sample-QC/InterimComparison/Interim-final-comparison-Totals.RData"),verbose=TRUE)

fracNonMissing = unlist( lapply(CSsum,function(x) x[,"nCallChanges"]/x[,"nonMissingBoth"]) )
nonmissToMissCounts = unlist( lapply(CSsum,function(x) x[,"NmTom"]))
missToNonmissCounts = unlist( lapply(CSsum,function(x) x[,"mToNm"]))
missToNonmiss = unlist( lapply(CSsum,function(x) x[,"mToNm"]/rowSums(x[,c("mToNm","NmTom")])))
nonmissToMiss = unlist( lapply(CSsum,function(x) x[,"NmTom"]/rowSums(x[,c("mToNm","NmTom")])))

nSamples = sum(!is.na(fracNonMissing))
nSNPS = nSNPsSamplessum[1,1]


png(paste0("plots/",releaseSampleQCPrefix,"-InterimComparison-hist-frac-discordant.png"),width=1000,height=1000,res=150 )
M=mean(fracNonMissing,na.rm=TRUE)
par(lwd=0.5)
hist(fracNonMissing,breaks=100,xlab="Fraction of non-missing markers discordant",main=paste0(nSamples," overlapping samples\n",nSNPS," overlapping markers" ),col="grey35",border="lightgray")
abline(v=M,lty=3,col="black")
text(x=M,y=par()$usr[4],labels =round(M,5),xpd=NA,pos=3,offset=0.1)
dev.off()

#png(paste0("plots/",releaseSampleQCPrefix,"-InterimComparison-hist-frac-discordant-log10.png"),width=1000,height=1000,res=150 )
pdf(paste0("plots/",releaseSampleQCPrefix,"-InterimComparison-hist-frac-discordant-log10.pdf"),width=1000/150,height=1000/150)
par(lwd=0.5)
M = mean(fracNonMissing,na.rm=TRUE)
h=hist(log10(fracNonMissing),breaks=50,xlab="Fraction of non-missing markers discordant",main=paste0("Discordance with samples in interim data release"),col="grey35",border="lightgray",xaxt="n")

myScale = getLogTicks(nticks=10,powers=-seq(5,2,by=-0.4),lims=10^par()$usr[1:2])
myLabels = get10power(myScale[[1]],minPower=-1,digits=2)
axis(1,at = log10(myScale[[1]]),labels=myLabels,cex=0.5,lwd=0,lwd.ticks=1)
axis(1,at = log10(myScale[[2]]),labels=NA,cex=0.7,tcl=-0.2,lwd=0,lwd.ticks=0.7)
axis(1,at = log10(myScale[[3]]),labels=NA,cex=0.7,lwd.ticks=0) # draw the axis line

abline(v=log10(M),lty=5,col="blue",lwd=1.5)
text(x=log10(M),y=par()$usr[4],labels=get10power(M,digits=3)[[1]],xpd=NA,pos=3,offset=0.1,cex=0.7)
legend("topright",c(paste0(nSamples," overlapping samples       "),paste0(nSNPS," overlapping markers     ")),pt.cex=0,inset=c(0.04,0.3))
dev.off()

print( paste0("Average discordance: ",M*100,"%") )


#png(paste0("plots/",releaseSampleQCPrefix,"-InterimComparison-hist-frac-concordant.png"),width=1000,height=1000,res=150 )
pdf(paste0("plots/",releaseSampleQCPrefix,"-InterimComparison-hist-frac-concordant.pdf"),width=1000/150,height=1000/150)
M=100*(mean(1-fracNonMissing,na.rm=TRUE))
Min = min(100*(1-fracNonMissing),na.rm=TRUE)
par(lwd=0.5)
hist(100*(1-fracNonMissing),breaks=100,xlab="% of non-missing genotype calls which are identical",main=paste0("Concordance with genotype data in interim data release"),col="grey35",border="lightgray",xlim=c(Min,100),xaxt="n")
axis(1,at=seq(99.3,100,by=0.01))
abline(v=M,lty=3,col="black")
text(x=M,y=par()$usr[4],labels =paste0(round(M,4),"%"),xpd=NA,pos=3,offset=0.1)
legend(99.95,30000,legend=c(paste0(nSamples," overlapping samples     "),paste0(nSNPS," overlapping markers     " )),pch=NA,col=NA,pt.cex=0,xjust=0.5)
dev.off()



png(paste0("plots/",releaseSampleQCPrefix,"-InterimComparison-hist-frac-toNon-Missing.png"),width=1000,height=1000,res=150 )
M=mean(missToNonmiss,na.rm=TRUE)
par(lwd=0.5)
hist(missToNonmiss,breaks=100,xlab="Fraction of markers missing in interim but not missing in final",main=paste0(nSamples," overlapping samples\n",nSNPS," overlapping markers"),col="grey35",border="lightgray")
abline(v=M,lty=3,col="black")
text(x=M,y=par()$usr[4],labels = round(M,3),xpd=NA,pos=3,offset=0.1)
dev.off()

png(paste0("plots/",releaseSampleQCPrefix,"-InterimComparison-hist-count-toNon-Missing.png"),width=1000,height=1000,res=150 )
M=mean(missToNonmissCounts,na.rm=TRUE)
par(lwd=0.5)
hist(missToNonmissCounts,breaks=100,xlab="Number of markers missing in interim but not missing in final",main=paste0(nSamples," overlapping samples\n",nSNPS," overlapping markers"),col="darkgray",border="lightgray")
abline(v=M,lty=3,col="black")
text(x=M,y=par()$usr[4],labels = round(M,0),xpd=NA,pos=3,offset=0.1)
dev.off()



png(paste0("plots/",releaseSampleQCPrefix,"-InterimComparison-hist-count-to-Missing.png"),width=1000,height=1000,res=150 )
M=mean(nonmissToMissCounts,na.rm=TRUE)
par(lwd=0.5)
hist(nonmissToMissCounts,breaks=100,xlab="Number of markers non-missing in interim but missing in final",main=paste0(nSamples," overlapping samples\n",nSNPS," overlapping markers"),col="grey35",border="lightgray")
abline(v=M,lty=3,col="black")
text(x=M,y=par()$usr[4],labels = round(M,0),xpd=NA,pos=3,offset=0.1)
dev.off()


########################################################
####### Missing rates for SNPs  <=== DO NOT USE!!

# across all samples

lmissFile = paste0(GenotypesForReleaseFiles,".missing.lmiss")
lmiss = read.table(lmissFile,header=TRUE,stringsAsFactors=FALSE)

missFracSNPs = lmiss$F_MISS

png(paste0("plots/",releaseSampleQCPrefix,"-missing-rates-snps-all-samples.png"),width=1000,height=1000,res=150 )
par(lwd=0.5)
hist(missFracSNPs,breaks=100,xlab="Fraction of samples with missing call",main=paste0(length(missFrac)," markers" ),col="grey35",border="white",xlim=c(0,max(missFracSNPs)))
dev.off()


# by allele frequency bins
#mafBins = c(0,1/1000,1/100,5/100,Inf)
#myBinCols = c("red","purple","blue","green")
#names(mafBins) = paste0("[",paste(mafBins[1:(length(mafBins)-1)],mafBins[2:length(mafBins)],sep=","),")")
#names(mafBins)[length(mafBins)-1] = paste0("[",mafBins[length(mafBins)-1])

mafBins = c(0,1/10000,1/1000,1/100,5/100,Inf)
myBinCols = c("yellow","red","purple","blue","green")
names(mafBins) = paste0("[",paste(mafBins[1:(length(mafBins)-1)],mafBins[2:length(mafBins)],sep=","),")")
names(mafBins)[length(mafBins)-1] = paste0("[",mafBins[length(mafBins)-1])

# freqsFile = paste0(GenotypesForReleaseFiles,".freq")  <=== from COlin. Meanwhile just one chromosome.
# system(paste0(plink," --bfile ",GenotypesForReleaseFiles,".chr",i," --keep-allele-order --freqx --out ",baseSampleQCDir,"/data/Combined/",basename(GenotypesForReleaseFiles),".chr",i))

freqs = read.genotyped.maf()
print(range(freqs$MAF))

# only snps on both arrays
inBoth = freqs$SNP%in%c(ps2snpBoth$dbSNPRSID,ps2snpBoth$AffySNPID)

# get bins
myBin = rep(NA,dim(lmiss)[1])
for (i in 2:length(mafBins)) {

r = mafBins[(i-1):i]
snps = freqs$SNP[(freqs$MAF>=r[1])&(freqs$MAF<r[2])&(inBoth)]
myBin[lmiss$SNP%in%snps] = mafBins[i-1]

}

png(paste0("plots/",releaseSampleQCPrefix,"-missing-rates-snps-all-samples-by-MAF.png"),width=1000,height=1000,res=150 )
par(lwd=0.5,mfrow=c(2,2))

for (i in 2:length(mafBins)) {
x = missFracSNPs[myBin==mafBins[i-1]]

if(i==2) hist(x,breaks=seq(0,1,0.01),xlab="Fraction of samples with missing call",main=paste0(length(missFracSNPs)," samples" ),col=My.add.alpha2(myBinCols[i-1],alpha=0.2),border="white",xlim=c(0,max(missFracSNPs)),freq=FALSE)

if(i!=2) hist(x,breaks=seq(0,1,0.01),col=My.add.alpha2(myBinCols[i-1],alpha=0.2),border="white",freq=FALSE)

}

dev.off()

png(paste0("plots/",releaseSampleQCPrefix,"-missing-rates-snps-all-samples-by-MAF-boxplot.png"),width=1000,height=1000,res=150 )
par(lwd=0.5,mfrow=c(2,2))

if(i==2) hist(x,breaks=seq(0,1,0.01),xlab="Fraction of samples with missing call",main=paste0(length(missFracSNPs)," samples" ),col=My.add.alpha2(myBinCols[i-1],alpha=0.2),border="white",xlim=c(0,max(missFracSNPs)),freq=FALSE)

if(i!=2) hist(x,breaks=seq(0,1,0.01),col=My.add.alpha2(myBinCols[i-1],alpha=0.2),border="white",freq=FALSE)

}

dev.off()


####### Missing rates for individuals <====== UPDATE LATER BASED ON COLIN'S INPUT FILES!!!

# across all autosomes
imissFile = paste0(GenotypesForReleaseFiles,".chr1-22.imiss.txt")
imiss = read.table(imissFile,header=FALSE,stringsAsFactors=FALSE)

missFracSamples = imiss$V6

png(paste0("plots/",releaseSampleQCPrefix,"-missing-rates-samples-all-snps.png"),width=1000,height=1000,res=150 )
par(lwd=0.5)
hist(missFracSamples,breaks=100,xlab="Fraction of markers with missing call",main=paste0(length(missFracSamples)," samples" ),col="darkgray",border="white",xlim=c(0,max(missFracSamples)))
dev.off()




##########################################
# Array test chr15 region
##########################################

# see: /well/ukbiobank/qcoutput.V2_QCed.sample-QC/QC-Scripts/GWAS/otherGWAS/Array.as.binary/compareToArrayEffectTest.R

# PLOTS:

# /well/ukbiobank/qcoutput.V2_QCed.sample-QC/QC-Scripts/GWAS/otherGWAS/Array.as.binary/plots/Region.plots/V2_QCed.UKBiLEVEAX_b1-b11.Batch_b001-b095.autosome.array_test-chr15-region-78868636-rs72740964.png
# and: Array.as.binary/plots/Region.plots/V2_QCed.UKBiLEVEAX_b1-b11.Batch_b001-b095.autosome.array_test-chrgenome-region-78868636-rs72740964-withClusterPlots.pdf



##########################################
# Some cluster plots ==> QC failures
##########################################

# cd /well/ukbiobank/qcoutput.V2_QCed.sample-QC/QC-Scripts/forPaper/plots
# SNPs are extracted from SNP-QC file.

# image artefact in original unqc'd data.
Rscript /well/ukbiobank/qcoutput.V2_QCed.sample-QC/QC-Scripts/R/scripts/V2_QCed.makeClusterPlots_v2.R /well/ukbiobank/expt/V2_QCed.SNP-QC/data Affx-52120205,Affx-2896814 cluster_plots_image -b Batch_b010-Batch_b020 -pdf -nocounts -nossp &

# batch
Rscript /well/ukbiobank/qcoutput.V2_QCed.sample-QC/QC-Scripts/R/scripts/V2_QCed.makeClusterPlots_v2.R /well/ukbiobank/expt/V2_QCed.SNP-QC/data Affx-10156038,Affx-32717971,Affx-7649432,Affx-19597397 cluster_plots_batch -b Batch_b010-Batch_b020 -pdf -nocounts &

Rscript /well/ukbiobank/qcoutput.V2_QCed.sample-QC/QC-Scripts/R/scripts/V2_QCed.makeClusterPlots_v2.R /well/ukbiobank/expt/V2_QCed.SNP-QC/data Affx-19597397 cluster_plots_batch -b Batch_b001-Batch_b004 -onepage -pdf -nocounts -nossp -rNumber 43779 &
    
Rscript /well/ukbiobank/qcoutput.V2_QCed.sample-QC/QC-Scripts/R/scripts/V2_QCed.makeClusterPlots_v2.R /well/ukbiobank/expt/V2_QCed.SNP-QC/data Affx-19597397 cluster_plots_batch -b Batch_b001-Batch_b004 -onepage -nocounts -nossp -rNumber 43779 &

# plate
    #Affx-4766400,Affx-35371680,
Rscript /well/ukbiobank/qcoutput.V2_QCed.sample-QC/QC-Scripts/R/scripts/V2_QCed.makeClusterPlots_v2.R /well/ukbiobank/expt/V2_QCed.SNP-QC/data Affx-14796791 cluster_plots_plate -b Batch_b002-Batch_b003 -colour Processed.Plate.Name -pdf -nossp -nocounts -maxcol 2 -rNumber 40005 &

# sex
#Affx-34897568,Affx-37677016,Affx-35119527,
    Rscript /well/ukbiobank/qcoutput.V2_QCed.sample-QC/QC-Scripts/R/scripts/V2_QCed.makeClusterPlots_v2.R /well/ukbiobank/expt/V2_QCed.SNP-QC/data Affx-6581316 cluster_plots_gender -b Batch_b001,Batch_b002,Batch_b003 -pdf -nocounts -nossp -sex -rNumber 57302 &
    Rscript /well/ukbiobank/qcoutput.V2_QCed.sample-QC/QC-Scripts/R/scripts/V2_QCed.makeClusterPlots_v2.R /well/ukbiobank/expt/V2_QCed.SNP-QC/data Affx-6581316 cluster_plots_gender -b Batch_b001,Batch_b002,Batch_b003 -nocounts -nossp -sex -rNumber 57302 &
    
# array
Rscript /well/ukbiobank/qcoutput.V2_QCed.sample-QC/QC-Scripts/R/scripts/V2_QCed.makeClusterPlots_v2.R /well/ukbiobank/expt/V2_QCed.SNP-QC/data Affx-10096426 cluster_plots_array -b UKBiLEVEAX_b1,UKBiLEVEAX_b2,Batch_b071,Batch_b072 -onepage -pdf -nocounts -nossp -rNumber 67059 &
Rscript /well/ukbiobank/qcoutput.V2_QCed.sample-QC/QC-Scripts/R/scripts/V2_QCed.makeClusterPlots_v2.R /well/ukbiobank/expt/V2_QCed.SNP-QC/data Affx-10096426 cluster_plots_array -b UKBiLEVEAX_b1,UKBiLEVEAX_b2,Batch_b071,Batch_b072 -onepage -nocounts -nossp -rNumber 67059 &

 # hwe
Rscript /well/ukbiobank/qcoutput.V2_QCed.sample-QC/QC-Scripts/R/scripts/V2_QCed.makeClusterPlots_v2.R /well/ukbiobank/expt/V2_QCed.SNP-QC/data Affx-14343512 cluster_plots_hwe -b UKBiLEVEAX_b1,Batch_b001,UKBiLEVEAX_b2,Batch_b002 -pdf -nocounts -nossp -rNumber 57544 &
Rscript /well/ukbiobank/qcoutput.V2_QCed.sample-QC/QC-Scripts/R/scripts/V2_QCed.makeClusterPlots_v2.R /well/ukbiobank/expt/V2_QCed.SNP-QC/data Affx-14343512 cluster_plots_hwe -b UKBiLEVEAX_b1,Batch_b001,UKBiLEVEAX_b2,Batch_b002 -nocounts -nossp -rNumber 57544 &
    

# Get the p-values!

##########################################
# Some more cluster plots ==> different allele freqs and number of batches failed.
##########################################
# NOTE: you need to have run the SNP-QC by batch section!
 
#snpqc # <==== The order of SNPs
#snpqcNbatches # Number of batches failing
#snpqcMaf # maf
#snpqcMac # mac
missL = lmiss$F_MISS[match(snpqc$rs_id,lmiss$SNP)] # missing rates
exacInfo = exacUKB[match(snpqc$rs_id,exacUKB$SNP),] # exac info
inExac = !is.na(exacInfo$MAF_exac_align)
# what snp failures occurred?
qcfails = read.SNPQC.files(justSNPs=FALSE)
qcfailsSNPs = read.SNPQC.files(justSNPs=TRUE)
failedOxford = snpqc$affymetrix_snp_id%in%unlist(qcfailsSNPs)

# Make sure they are on both arrays. 
inBothArrays = snpqc$affymetrix_snp_id%in%ps2snpBoth$AffySNPID
# failing no batches:
set.seed(123456)
# Common SNP
snp1 = sample(snpqc$affymetrix_snp_id[(snpqcMaf>0.05)&(snpqcNbatches==0)&(inBothArrays)],4)
# low freq SNP
snp2 = sample(snpqc$affymetrix_snp_id[(snpqcMaf<0.01)&(snpqcNbatches==0)&(inBothArrays)],4)
# very low freq SNP 
snp3 = sample(snpqc$affymetrix_snp_id[(snpqcMaf<0.001)&(snpqcNbatches==0)&(inBothArrays)],4)
# failing some batches:
# Common SNP
snp4 = sample(snpqc$affymetrix_snp_id[(snpqcMaf>0.05)&(snpqcNbatches%in%c(2:5))&(inBothArrays)],4)
# low freq SNP
snp5 = sample(snpqc$affymetrix_snp_id[(snpqcMaf<0.01)&(snpqcNbatches%in%c(2:5))&(inBothArrays)],4)
# very low freq SNP 
snp6 = sample(snpqc$affymetrix_snp_id[(snpqcMaf<0.001)&(snpqcNbatches%in%c(2:5))&(inBothArrays)],4)

# failing no batches and lowest missing rates. <== likely to be very good snps
snp7 = sample(snpqc$affymetrix_snp_id[(snpqcMaf>0.05)&(snpqcNbatches==0)&(inBothArrays)&(missL<0.0002)],4)

snp8 = sample(snpqc$affymetrix_snp_id[(snpqcMaf>0.0001)&(snpqcMaf<0.001)&(snpqcNbatches==0)&(inBothArrays)&(missL<0.0002)],4)

# low freq in ExAC and also low freq in UKB, and some missing batches...
snp9 = sample(snpqc$affymetrix_snp_id[(snpqcMaf>0.0001)&(snpqcMaf<0.001)&(snpqcNbatches==2)&(inBothArrays)&(exacInfo$MAF_exac_align>0.0001)&(inExac)],4)

# Failed Oxford qc at least once
snp10 = sample(snpqc$affymetrix_snp_id[(snpqcMaf>0.0001)&(snpqcMaf<0.001)&(snpqcNbatches%in%c(2:4))&(inBothArrays)&(exacInfo$MAF_exac_align>0.0001)&(inExac)&(failedOxford)],4)


# properties of these SNPs
mySNPs = c(snp1,snp2,snp3,snp4,snp5,snp6,snp7,snp8,snp9,snp10)
index = match(mySNPs,snpqc$affymetrix_snp_id)

selectionSNPs = cbind(snpqc[index,1:5],snpqcNbatches[index],snpqcMaf[index],snpqcMac[index],missL[index],exacInfo[index,20:36])

save(selectionSNPs,file=paste0("SNP-for-example-cluster-plots.RData"))


# plot them!
forSystem= paste0("Rscript /well/ukbiobank/qcoutput.V2_QCed.sample-QC/QC-Scripts/R/scripts/V2_QCed.makeClusterPlots_v2.R /well/ukbiobank/expt/V2_QCed.SNP-QC/data ",paste(mySNPs[37:40],collapse=",")," cluster_plots_examples -onepage -nocounts -released -maxcols 6 -maf -rNumber 57544 &")

# what batches failed what test?
mysnpfails = sapply(mySNPs,function(i){
    print(i)
if(!i%in%unlist(qcfailsSNPs)) return(NULL)
sapply(qcfails,function(f) if(i%in%f) as.data.frame(f)[apply(as.data.frame(f),1,function(x) grepl(i,x)),] else return(NULL))
})

###### 
# SNPS WE CHOSE

# Common, successful:
s1 = "Affx-3639797"
b1 = c(ukbileve.batches()[1:3],ukbiobank.batches()[1:3])

# Rare, successful:
s2 = "Affx-52242951"
b2 = c(ukbileve.batches()[4:6],ukbiobank.batches()[43:45])
    
# Very rare, somewhat successful:
s3 = "Affx-52268215"
b3 = c(ukbileve.batches()[c(7,9)],ukbiobank.batches()[c(18,79,80,81)])
b3b = c(ukbileve.batches()[c(7:9)],ukbiobank.batches()[c(18,79,80,81,47,52)]) # with the batch-test failed batches!


forSystem= paste0("Rscript /well/ukbiobank/qcoutput.V2_QCed.sample-QC/QC-Scripts/R/scripts/V2_QCed.makeClusterPlots_v2.R /well/ukbiobank/expt/V2_QCed.SNP-QC/data ",paste(s1)," plots/cluster_plots_examples -b ",paste(b1,collapse=",")," -onepage -nocounts -released -nossp -maxcols 3 -rNumber 1111 &")
system(forSystem)

forSystem= paste0("Rscript /well/ukbiobank/qcoutput.V2_QCed.sample-QC/QC-Scripts/R/scripts/V2_QCed.makeClusterPlots_v2.R /well/ukbiobank/expt/V2_QCed.SNP-QC/data ",paste(s2)," plots/cluster_plots_examples -b ",paste(b2,collapse=",")," -onepage -nocounts -released -nossp -maxcols 3 -rNumber 1112 &")
system(forSystem)

forSystem= paste0("Rscript /well/ukbiobank/qcoutput.V2_QCed.sample-QC/QC-Scripts/R/scripts/V2_QCed.makeClusterPlots_v2.R /well/ukbiobank/expt/V2_QCed.SNP-QC/data ",paste(s3)," plots/cluster_plots_examples -b ",paste(b3,collapse=",")," -onepage -nocounts -released -nossp -maxcols 3 -rNumber 1113 &")
system(forSystem)

forSystem= paste0("Rscript /well/ukbiobank/qcoutput.V2_QCed.sample-QC/QC-Scripts/R/scripts/V2_QCed.makeClusterPlots_v2.R /well/ukbiobank/expt/V2_QCed.SNP-QC/data ",paste(s3)," plots/cluster_plots_examples -b ",paste(b3b,collapse=",")," -onepage -nocounts -released -nossp -maxcols 3 -rNumber 1114 &")
system(forSystem)

index = match(c(s1,s2,s3),snpqc$affymetrix_snp_id)
inf = cbind(snpqc[index,1:5],snpqcNbatches[index],snpqcMaf[index],snpqcMac[index],missL[index],exacInfo[index,20:36])


##########################################
# Some cluster plots ==> APOE
##########################################

# GWAS catalogue snps
# Rscript /well/ukbiobank/qcoutput.V2_QCed.sample-QC/QC-Scripts/R/scripts/V2_QCed.makeClusterPlots_v2.R /well/ukbiobank/expt/V2_QCed.SNP-QC/data rs429358,rs7412 cluster_plots_APOE -b Batch_b001-Batch_b010 -released -onepage -nossp -maxcol 2 -nocounts -pdf -rNumber 1234 &

# just 3 batches on one page
# Rscript /well/ukbiobank/qcoutput.V2_QCed.sample-QC/QC-Scripts/R/scripts/V2_QCed.makeClusterPlots_v2.R /well/ukbiobank/expt/V2_QCed.SNP-QC/data rs429358,rs7412 cluster_plots_APOE -b Batch_b001-Batch_b003 -released -onepage -nossp -maxcol 2 -nocounts -pdf -rNumber 1245 &

# just 10 batches on one page
# Rscript /well/ukbiobank/qcoutput.V2_QCed.sample-QC/QC-Scripts/R/scripts/V2_QCed.makeClusterPlots_v2.R /well/ukbiobank/expt/V2_QCed.SNP-QC/data rs429358,rs7412 cluster_plots_APOE -b UKBiLEVEAX_b1-Batch_b050 -released -onepage -nossp -maxcol 5 -nocounts -pdf -rNumber 1250 &

apoeGene = c(45409006,45412652)
apoe = (ps2snpEither$Chromosome==19)&(ps2snpEither$Position >= apoeGene[1])&(ps2snpEither$Position <= apoeGene[2])


source("/well/donnelly/ukbiobank_project_8874/clare/sex/scripts/commonScripts/plotGenesFunction.R")
genes = load.genes(refGeneFile,fieldNames=fieldNames)
exons = get.exons(genes,chromosome = 19)


# all snps in region
apoeSnps = ps2snpEither[apoe,]
apoeSnps$MAF = freqs$MAF[match(ps2snpEither$dbSNPRSID[apoe],freqs$SNP)]


# all snps in exonic regions
exonic =  rowSums(apply(exons[exons$name2=="APOE",],1,function(s){
    (apoeSnps$Position >= s[5])&(apoeSnps$Position <= s[6])
}))>0
apoeSnps$exonic = 1*exonic; 
apoeSnpsExon = apoeSnps$AffySNPID[apoeSnps$exonic==1]
apoeSnpsExonRsid = apoeSnps$dbSNPRSID[apoeSnps$exonic==1]


forSystem=paste0("Rscript /well/ukbiobank/qcoutput.V2_QCed.sample-QC/QC-Scripts/R/scripts/V2_QCed.makeClusterPlots_v2.R /well/ukbiobank/expt/V2_QCed.SNP-QC/data ",paste(apoeSnps,collapse=",")," cluster_plots_APOE -b Batch_b010,Batch_b020,Batch_b021 -released &")

system(forSystem)

toHighlight = c("Affx-89007749","Affx-89007946","Affx-16020324","Affx-16020316","Affx-92041827")

forSystem=paste0("Rscript /well/ukbiobank/qcoutput.V2_QCed.sample-QC/QC-Scripts/R/scripts/V2_QCed.makeClusterPlots_v2.R /well/ukbiobank/expt/V2_QCed.SNP-QC/data ",paste(toHighlight,collapse=",")," cluster_plots_APOE -released -onepage -legendonly &")

system(forSystem)


# plot 
region=apoeGene + c(-1,1)*500
exonCol = "blue"
indelChar  = 21


spaceForGenes=0.3

m=apoeSnps$MAF
m2 = m; m2[is.na(m)]=0
shapes=rep(23,length(m));
shapes[is.na(m)] = 3
shapes[apoeSnps$Variant=="INDEL"] = indelChar # INDELS

Y = log10(m2);
cap=ceiling(min(Y[Y!=-Inf]))-2

Y[Y==-Inf] = cap

cols=rep("red",length(Y))
cols[apoeSnps$AffySNPID%in%apoeSnpsExon] = exonCol # exonic snps


png("plots/test.png",width=41,height=12,units="in",res=150,bg="transparent")
par(mar=c(5,5,4.1,5),cex.axis=1.5,cex.lab=1.5)
layout(mat=c(1,2),heights=c( 1-spaceForGenes,spaceForGenes ) )


plot(x=ps2snpEither$Position[apoe],y=Y,xlim=region,bg=cols,col="black",pch=shapes,lwd=2,cex=2,
xlab="Position on chromosome 19")
                                        # add genes
legend("topright",legend=c("SNPs","INDELS","Exonic"),col=c("black","black",exonCol),pch=c(23,indelChar,15))

abline(h=cap,lty=3)
par( mar=c(2,5,0,5), bty="n") 
plot.genes(chromosome = formatChrom(19),region=region,local.genes=genes,exons=exons,label.cex=2,height_in_inches = 1)        

dev.off()



#################################
# Properties of the imputed data
#################################

# how many variants?

nsnps = system(paste0('wc -l ',gsub("%%","*",imputedMAFLists)),intern=TRUE)




#################################
# Properties of GWAS
#################################

# number of samples attempted after applying QC

# Standing height, imputation:
# more ../../GWAS/otherGWAS/Standing.height/Logs/bolt_lmm_v15.o2716828.1

# 343321 used with non-missing phenotype data.
# 344397 in QC'd set.



#################################
# GWAS Standing height p-values.
#################################

# Plots are based on this made in Standing.height/plot-GWAS-comparison.R
source("/well/donnelly/ukbiobank_project_8874/clare/sex/scripts/commonScripts/plotGenesFunction.R")
genes = load.genes(refGeneFile,fieldNames=fieldNames)

# p-value cap
Ymax=50

# which chromosome (imputation data only)
chrom=2

# known hits
load("/well/ukbiobank/qcoutput.V2_QCed.sample-QC/QC-Scripts/GWAS/otherGWAS/GWAScatalogue/hg19/gwasCatalog-subset-Standing.height.RData",verbose=TRUE)
catFile = catPheno  # just europeans
catFile$Pvalue = catFile$V18
catFile$SNP = catFile$V5
catFile$BP = catFile$V4 # this is the chromEnd field
catFile$CHR = gsub("chr","",catFile$V2)
catFile$CHR[catFile$CHR%in%names(sexChroms)] = sexChroms[catFile$CHR[catFile$CHR%in%names(sexChroms)]]
catFile$CHR = as.numeric(catFile$CHR)
print( head(catFile) )
catFileSub = catFile[catFile$CHR %in% chrom,]
catFileSub$Pvalue[-log10(catFileSub$Pvalue)>Ymax] = 10^(-Ymax)
colors = rep("red",dim(catFileSub)[1])


# gwas results genotypes    
resultsGENO = read.gwas("/well/ukbiobank/qcoutput.V2_QCed.sample-QC/data/GWAS/otherGWAS/Standing.height/BOLTLMM.v16/Standing.height-BOLT-LMM-v16.out",chrom="genome",minmaf=0,mininfo=0,maxmiss = 1,Ymax=Ymax,QCexclusions=c(),extraTitle="forPaper",useLmmInf=FALSE)
DF1 = resultsGENO$DF[resultsGENO$DF$CHR==chrom,]
#### 61966 markers

# gwas results imputation chromosome 2
#resultsIMP = read.gwas("/well/ukbiobank/qcoutput.V2_QCed.sample-QC/data/GWAS/otherGWAS/Standing.height/BOLTLMM.v15/Standing.height-BOLT-LMM-v15-chr2.out",chrom="genome",minmaf=0,mininfo=0,maxmiss = 1,Ymax=Ymax,QCexclusions=c(),extraTitle="forPaper",useLmmInf=FALSE)
#DF2 = resultsIMP$DF
# NEW VERSION AFTER FIXING IMPUTATION ANNOTATION BUG! NEED TO RUN ALL PLOTS AGAIN
resultsIMP = read.gwas("/well/ukbiobank/qcoutput.V2_QCed.sample-QC/data/GWAS/otherGWAS/Standing.height/BOLTLMM.v20/Standing.height-BOLT-LMM-v20-chr2.out",chrom="genome",minmaf=0,mininfo=0,maxmiss = 1,Ymax=Ymax,QCexclusions=c(),extraTitle="forPaper",useLmmInf=FALSE)
DF2 = resultsIMP$DF
### 8,129,063 markers

# hit regiions
load("/well/ukbiobank/qcoutput.V2_QCed.sample-QC/QC-Scripts/GWAS/otherGWAS/Standing.height/Standing.height-BOLT-LMM-v16.out.chrgenome.maf0.001.miss0.05.pruned-QCFiltered-lreg-hitsAndLDcalc.RData",verbose=TRUE)
HITSchromGENO = HITSchrom
LDchromGENO = LDchrom
load("/well/ukbiobank/qcoutput.V2_QCed.sample-QC/QC-Scripts/GWAS/otherGWAS/Standing.height/Standing.height-BOLT-LMM-v15-chr2.out.chr2.maf0.info0.pruned-raw-lreg-hitsAndLDcalc.RData",verbose=TRUE)
HITSchromIMP = HITSchrom
LDchromIMP = LDchrom


# recombination rates
recombrates=read.recomb(chrom=2)

# giant data
giant = read.table(gzfile('/well/ukbiobank/qcoutput.V2_QCed.sample-QC/QC-Scripts/GWAS/otherGWAS/Standing.height/GIANT/GIANT_HEIGHT_Wood_et_al_2014_publicrelease_HapMapCeuFreq-with-positions.txt.gz'),stringsAsFactors=FALSE,header=TRUE)
giant2 = giant[!is.na(giant$BP),]
                                        # cap the p-values at 50
giant2$P2 = giant2$P
giant2$P2[-log10(giant2$P)>Ymax] = 10^-Ymax
giantData = list("DF"=giant2,"Pvalset"="GIANT.chrgenome")


###### Set colours and xlimits
xLims =  c(floor(max(DF2$BP) * -0.02),ceiling(max(DF2$BP) * 1.02))/1000000 # in units of megabases

#giantColour = "dodgerblue2"
giantColour = "#0072B2" # From colourblind palette!
genoColour = "#009E73" # From colourblind palette!
phasedColour = getColBlindCol("r") # From colourblind palette!
rareColour = "blue"
infoColour = "orange"
rareThreshold = 0.001
#phased = read.phased.snps(chrom)[[1]]
#bgenSNPs = read.imputed.snps(chrom)[[1]]  # get alternative ID from bgen files. It's a bit

rareGeno = DF1$MAF < rareThreshold
inPhasedGeno = (DF1$SNP%in%DF2$SNP)&(DF1$SNP2%in%DF2$SNP2)
poorInfoGeno = DF1$F_MISS >= 0.05

rareImp = DF2$MAF < rareThreshold
inPhasedImp = (DF2$SNP%in%DF1$SNP)&(DF2$SNP2%in%DF1$SNP2) # match on the alleles too!
poorInfoImp = DF2$INFO < 0.3

colorsGeno = rep("black",dim(DF1)[1]) 
colorsGeno[inPhasedGeno]=phasedColour # in phased
colorsImp = rep("black",dim(DF2)[1]) 
colorsImp[inPhasedImp]=phasedColour # in phased

sub = sample(1:sum(giantData$DF$CHR==chrom),500,replace=FALSE)
######

# plot manhattans in png but with 450ppi resolution
png(paste("plots/",giantData$Pvalset,"-manhattan.png",sep=""),width=61,height=12,units="in",res=450,bg="transparent")
par(las=1,font.main=1,cex.axis=3,cex.lab=3,mar=c(8 ,10, 5 ,2),mgp=c(6,2,0))
myManhattan(giantData$DF[giantData$DF$CHR==chrom,],ymax=Ymax,suggestiveline = FALSE,xpd=NA,cex=1,col=giantColour,xlimits=xLims)
dev.off()

png(paste("plots/",giantData$Pvalset,"-GwasHits-manhattan.png",sep=""),width=61,height=13,units="in",res=450,bg="transparent")
#pdf(paste("plots/",giantData$Pvalset,"-GwasHits-manhattan.pdf",sep=""),width=61,height=13,bg="transparent")
par(las=1,font.main=1,cex.axis=5.1,cex.lab=5.1,mar=c(11 ,14, 5 ,2),mgp=c(8,4,0),tcl=-0.75,lwd=4)
myManhattan(giantData$DF[giantData$DF$CHR==chrom,],ymax=Ymax,suggestiveline = FALSE,xpd=NA,cex=2,col=giantColour,xlimits=xLims,lwd=4,printAxes=FALSE)
points(catFileSub$BP/1000000,-log10(catFileSub$Pvalue),pch=8,col=colors,cex=4.3,lwd=2.1,xpd=NA)
points(catFileSub$BP/1000000,-log10(catFileSub$Pvalue),pch=16,col=colors,cex=2.3,xpd=NA)
# anything above ymax in catalogue?
points(catFileSub$BP[-log10(catFileSub$V18)>Ymax]/1000000,-log10(catFileSub$Pvalue)[-log10(catFileSub$V18)>Ymax],pch=17,col=colors,cex=2.8,lwd=1,xpd=NA)
dev.off()

# Genotypes - lin regression
png(paste("plots/",resultsGENO$Pvalset,"-manhattan.png",sep=""),width=61,height=12,units="in",res=450,bg="transparent")
par(las=1,font.main=1,cex.axis=3,cex.lab=3,mar=c(8 ,10, 5 ,2),mgp=c(6,2,0))
myManhattan(DF1,ymax=Ymax,suggestiveline = FALSE,xpd=NA,cex=1,xlimits=xLims,col=genoColour)
dev.off()

# Genotypes - LMM results
png(paste("plots/",resultsGENO$Pvalset,"-LMM-manhattan.png",sep=""),width=61,height=13,units="in",res=450,bg="transparent")
par(las=1,font.main=1,cex.axis=5.1,cex.lab=5.1,mar=c(11 ,14, 5 ,2),mgp=c(8,4,0),tcl=-0.75,lwd=4)
myManhattan(DF1,ymax=Ymax,suggestiveline = FALSE,xpd=NA,cex=2,xlimits=xLims,col=genoColour,p="P_BOLT_LMM_INF",lwd=4,printAxes=FALSE)
dev.off()

pdf(paste("plots/",resultsGENO$Pvalset,"-LMM-manhattan-axesStuff.pdf",sep=""),width=61,height=13,bg="transparent")
par(las=1,font.main=1,cex.axis=5.1,cex.lab=5.1,mar=c(11 ,14, 5 ,2),mgp=c(8,4,0),tcl=-0.75,lwd=4)
myManhattan(DF1[1:2,],ymax=Ymax,suggestiveline = FALSE,xpd=NA,cex=1.8,xlimits=xLims,col=NA,p="P_BOLT_LMM_INF",lwd=4,hadj=0.5)
dev.off()

#png(paste("plots/",resultsGENO$Pvalset,"-LMM-manhattanTEST.png",sep=""),width=61,height=13,units="in",res=450,bg="transparent")
#pdf(paste("plots/",resultsGENO$Pvalset,"-LMM-manhattanTEST.pdf",sep=""),width=61,height=13,bg="transparent")
#par(las=1,font.main=1,cex.axis=5.1,cex.lab=5.1,mar=c(11 ,14, 5 ,2),mgp=c(8,4,0),tcl=-0.75,lwd=4)
#myManhattan(DF1,ymax=Ymax,suggestiveline = FALSE,xpd=NA,cex=2.1,xlimits=xLims,col=genoColour,p="P_BOLT_LMM_INF",lwd=4,printAxes=FALSE)
#dev.off()

#source('/well/ukbiobank/qcoutput.V2_QCed.sample-QC/QC-Scripts/R/scripts/myManhattan.R')

#pdf(paste("plots/",resultsGENO$Pvalset,"-LMM-manhattan.pdf",sep=""),width=2*20,height=2*4,bg="transparent")
#par(las=1,font.main=1,cex.axis=3,cex.lab=3,mar=c(8 ,10, 5 ,2),mgp=c(6,2,0))
#myManhattan(DF1[sub,],ymax=Ymax,suggestiveline = FALSE,xpd=NA,cex=1,xlimits=xLims,col=genoColour,p="P_BOLT_LMM_INF")
#dev.off()

#svg(paste("plots/",resultsGENO$Pvalset,"-LMM-manhattan.svg",sep=""),width=2*20,height=2*4,bg="transparent")
#par(las=1,font.main=1,cex.axis=3,cex.lab=3,mar=c(8 ,10, 5 ,2),mgp=c(6,2,0))
#myManhattan(DF1[sub,],ymax=Ymax,suggestiveline = FALSE,xpd=NA,cex=1,xlimits=xLims,col=genoColour,p="P_BOLT_LMM_INF")
#dev.off()


# Imputation - linear regression
png(paste("plots/",resultsIMP$Pvalset,"-manhattan.png",sep=""),width=61*0.75,height=12*0.75,units="in",res=450,bg="transparent")
par(las=1,font.main=1,cex.axis=4,cex.lab=4,mar=c(10 ,12, 5 ,2),mgp=c(8,3,0),tcl=-0.75)
myManhattan(DF2[colorsImp=="black",],ymax=Ymax,suggestiveline = FALSE,xpd=NA,cex=1.8,xlimits=xLims,col="black")
points(DF2$BP[colorsImp==phasedColour]/1000000,-log10(DF2$P2[colorsImp==phasedColour]),col=phasedColour,pch=16,cex=1.8)
points(DF2$BP[(colorsImp==phasedColour)&(DF2$P<10^-Ymax)]/1000000,-log10(DF2$P2[(colorsImp==phasedColour)&(DF2$P<10^-Ymax)]),col=phasedColour,pch=17,cex=1.8)
dev.off()

# Imputation - lmm
PVALS = DF2$P_BOLT_LMM_INF
PVALS[-log10(PVALS) > Ymax] = 10^-Ymax

png(paste("plots/",resultsIMP$Pvalset,"-LMM-manhattan.png",sep=""),width=61,height=13,units="in",res=450,bg="transparent")
par(las=1,font.main=1,cex.axis=5.1,cex.lab=5.1,mar=c(11 ,14, 5 ,2),mgp=c(8,4,0),tcl=-0.75,lwd=4)
myManhattan(DF2[colorsImp=="black",],ymax=Ymax,suggestiveline = FALSE,xpd=NA,cex=2,xlimits=xLims,col="black",p="P_BOLT_LMM_INF",lwd=4,printAxes=FALSE)

points(DF2$BP[colorsImp==phasedColour]/1000000,-log10(PVALS[colorsImp==phasedColour]),col=phasedColour,pch=16,cex=2,xpd=NA)
# add triangles for capped values
points(DF2$BP[(colorsImp==phasedColour)&(DF2$P_BOLT_LMM_INF<10^-Ymax)]/1000000,-log10(PVALS[(colorsImp==phasedColour)&(DF2$P_BOLT_LMM_INF<10^-Ymax)]),col=phasedColour,pch=17,cex=2.1,xpd=NA)
dev.off()

                                        # Legend for manhattans!
pdf(paste0("plots/Standing.height.manhattan-LEGEND.pdf"),width=61,height=12,bg="transparent")
plot.new()
l = legend("top",legend=c("","","","",""),pch=16,col=c("red",giantColour,genoColour,phasedColour,"black"),pt.cex=3,xpd=NA,bty="n",cex=3)
legend(l$rect$left,l$rect$top,legend=c("GWAS catalogue","GIANT markers (2014)","UK Biobank - genotyped markers","UK Biobank - genotyped markers in imputed data","UK Biobank - imputed markers"),col=c("red",NA,NA,NA,NA),bty="n",pch=c(8,NA,NA,NA,NA),pt.cex=5,border=NA,cex=3)

dev.off()


###### qqplot?



##############################
###### Region plot.

exons = get.exons(genes,chromosome = chrom)
HITS = HITSchromGENO[[as.character(chrom)]]
ld = LDchromGENO[[as.character(chrom)]]
ldIMP = LDchromIMP[[as.character(chrom)]]
recomb = recombrates[[as.character(chrom)]]

#######
s = 51  # <- closest to telomeric end.
######
regionToPlot = c(max(HITS$regs[s,1],0,min(DF2$BP)),HITS$regs[s,2])

# NOTE: only plot the imputed snps that aren't weren't in the genotype data (i.e in the phased set). Also not showing recombination rates

myreg = plot.gwas.region.v2(resultsGENO$DF,HITS$topVariants[s],catFile=catFile,ld=ld,ldIMP=ldIMP,plotDir=paste0("plots"),recombRates=NULL,region=regionToPlot,Ymax=16,width=(10^6)/3,moreToPlot=TRUE,Pvalset= paste0(resultsGENO$Pvalset,"-withImputed"),addGenes=list("genes"=genes,"exons"=exons),ldColours=colorRampPalette(c("#FBBE22FF","darkred"))(10),
                    showRegion=NULL,axisScale=1000,
                    basicCol=genoColour,xlabExtra = " (Kb)",
                    imputedSNPs=DF2[!inPhasedImp,],imputeCex=1.4,imputeCol="black",pdf=FALSE,resScale=3)#,extraPoints=giantData$DF[(giantData$DF$CHR==chrom)&(giantData$DF$BP<=regionToPlot[2]),],extraPointsPch=16,extraPointsCex=1.6,extraPointsCol=add.alpha(giantColour,0.5))
dev.off()

# Plot the recombination rates only on the same axis
png(paste0("plots/",resultsGENO$Pvalset,"-withImputed-recombOnly.png"),width=30,height=6,bg="transparent",res=3*150,units="in")
par(mar=c(5,5,4.1,5),cex.axis=2.2,cex.lab=2.2)
region= myreg
recombMax = max(recomb$COMBINED_rate.cM.Mb.) # maximum recombination rate on chromsome
recomPos = (recomb$position >= region[1]) & (recomb$position <= region[2])
xrecom=recomb$position[recomPos]
yrecom=recomb$COMBINED_rate.cM.Mb.[recomPos]
plot(NULL,ylim = range(yrecom),xlim=region,xaxt="n",
     xlab=paste0( "Position on chromosome ",chrom," (Kb)"),ylab = "Recombination rate (cM/Mb)")
lines(xrecom,yrecom,col="blue",lwd=2)
axis(1,at = axTicks(1),labels=axTicks(1)/1000)
dev.off()



# Legend for region plot!
pdf(paste0("plots/Standing.height.regionPlot-LEGEND.pdf"),width=61/3,height=12/3,bg="transparent")
plot.new()
l = legend("top",legend=c("GIANT 2014","UK Biobank - genotyped","UK Biobank - phased or imputed","Recombination rate"),pch=c(16,23,16,NA),col=c(add.alpha(giantColour,0.5),genoColour,"black","blue"),pt.bg=genoColour,pt.cex=c(1.6,2,1.8,NA),lwd=c(NA,NA,NA,2),xpd=NA,bty="n",cex=2)
dev.off()

pdf(paste0("plots/Standing.height.regionPlot-SCALE.pdf"),width=1.2,height=5,bg="transparent")
par(mar=c(1,3,3,1))
plot.new()
# parameters should match that in plot.gwas.region.v2
Colors <- colorRampPalette(colorRampPalette(c("#FBBE22FF","darkred"))(10),space="Lab")(200)
Scale <- seq(0.1,1+0.0001,length.out=200)
colindex<-matrix(Scale,nrow=1,ncol=length(Scale)) # colour scale
image(1,Scale,colindex,col=Colors,add=TRUE,axes=FALSE)
#rect(par()$usr[1],par()$usr[3],par()$usr[2],0.1,border="gray",col="gray")
axis(2,at=seq(0.1,1,by=0.1),las=2,cex.axis=1.2,lwd=0.5)
mtext(text=expression(r^2),side=3,cex=2)
dev.off()


####################################
# Scatter plot comparing p-values

giantData$DF$SNP2a = altSNPID(giantData$DF$CHR,giantData$DF$BP,giantData$DF$Allele1,giantData$DF$Allele2)
giantData$DF$SNP2b = altSNPID(giantData$DF$CHR,giantData$DF$BP,giantData$DF$Allele2,giantData$DF$Allele1)

# all genotypes (autosomes)
DF1 = resultsGENO$DF

genoIndexA = match(DF1$SNP2,giantData$DF$SNP2a)
genoIndexB = match(DF1$SNP2,giantData$DF$SNP2b)
genoIndex = genoIndexA; genoIndex[is.na(genoIndexA)] = genoIndexB[is.na(genoIndexA)]
    
giantGeno = giantData$DF[genoIndex,] # Giant at the same genotypes. 
                                        # Ignore anything that does not match on one of the alleles
print( paste0( sum(!is.na(giantGeno$SNP))," snps in genotype data match with giant snps.") )
print( paste0( dim(DF1)[1]," snps in genotype data.") )


# imputed
impIndexA = match(DF2$SNP2,giantData$DF$SNP2a)
impIndexB = match(DF2$SNP2,giantData$DF$SNP2b)
impIndex = impIndexA; impIndex[is.na(impIndexA)] = impIndexB[is.na(impIndexA)]

giantImp = giantData$DF[impIndex,] # Giant at the same genotypes

print( paste0( sum(!is.na(giantImp$SNP))," snps in genotype data match with giant snps.") )
print( paste0( dim(DF2)[1]," snps in imputed data.") )

######
rareThreshold = 0.001
######

rareGeno = DF1$MAF < rareThreshold


myTheme = theme_bw() + theme(aspect.ratio=1)
my_breaks = 10^seq(0,10,1)

#######
#### Just the genotype data at all autosomes

x = -log10(giantGeno$P)
y = -log10(DF1$P)   # linear regression results

data = data.frame(cbind(x,y))
colnames(data) = c("GIANT","UKBiobank")

noNA = (!is.na(x))&(!is.na(y))

#pdf(paste0('plots/Standing.height.GIANTcomparisonPval.genotypes.chr',chrom,'.pdf'),bg="transparent",width=1500/150)
pdf(paste0('plots/Standing.height.GIANTcomparisonPval.genotypes.autosomes.pdf'),bg="transparent",width=1500/150)

d <- ggplot(data[noNA,], aes(GIANT, UKBiobank)) + stat_binhex(bins=100) + scale_fill_gradientn(name="Marker count" ,breaks=rev(my_breaks),trans="log10",colors=viridis_pal()(10),labels = get10power2) +  scale_x_continuous( expand = c(0.05, 0.05),name=expression(-log[10](italic(p))~"in GIANT (2014)") ) +
    scale_y_continuous(expand = c(0.05, 0.05),name=expression(-log[10](italic(p))~"in UK Biobank genotype data")) + geom_abline(slope=1, intercept=0,color="red",linetype="longdash")+ ggtitle(paste0( sum(noNA)," overlapping markers")) + myTheme
    
print(d)
dev.off()

##
y = -log10(DF1$P_BOLT_LMM_INF) # LMM results

data = data.frame(cbind(x,y))
colnames(data) = c("GIANT","UKBiobank")

noNA = (!is.na(x))&(!is.na(y))

#pdf(paste0('plots/Standing.height.GIANTcomparisonPval.genotypes.chr',chrom,'.pdf'),bg="transparent",width=1500/150)
pdf(paste0('plots/Standing.height.GIANTcomparisonPval-LMM.genotypes.autosomes.pdf'),bg="transparent",width=1500/150)

d <- ggplot(data[noNA,], aes(GIANT, UKBiobank)) + stat_binhex(bins=100) + scale_fill_gradientn(name="Marker count" ,breaks=rev(my_breaks),trans="log10",colors=viridis_pal()(10),labels = get10power2) +  scale_x_continuous( expand = c(0.05, 0.05),name=expression(-log[10](italic(p))~"in GIANT (2014)") ) +
    scale_y_continuous(expand = c(0.05, 0.05),name=expression(-log[10](italic(p))~"in UK Biobank genotype data")) + geom_abline(slope=1, intercept=0,color="red",linetype="longdash")+ ggtitle(paste0( sum(noNA)," overlapping markers")) + myTheme
    
print(d)
dev.off()

################
#### Just the imputed data at chromosome 2
x = -log10(giantImp$P)  
y = -log10(DF2$P) # linear regression results

data = data.frame(cbind(x,y))
colnames(data) = c("GIANT","UKBiobank")

noNA = (!is.na(x))&(!is.na(y))


pdf(paste0('plots/Standing.height.GIANTcomparisonPval.imputed.chr',chrom,'.pdf'),bg="transparent",width=1500/150)

d <- ggplot(data[noNA,], aes(GIANT, UKBiobank)) + stat_binhex(bins=100) + scale_fill_gradientn(name="Marker count" ,breaks=rev(my_breaks),trans="log10",colors=viridis_pal()(10),labels = get10power2) +  scale_x_continuous( expand = c(0.05, 0.05),name=expression(-log[10](italic(p))~"in GIANT (2014)") ) +
    scale_y_continuous(expand = c(0.05, 0.05),name=expression(-log[10](italic(p))~"in UK Biobank imputed data") ) + geom_abline(slope=1, intercept=0,color="red",linetype="longdash")+ ggtitle(paste0( sum(noNA)," overlapping markers")) + myTheme
    
print(d)
dev.off()


#######
x = -log10(giantImp$P)  
y = -log10(DF2$P_BOLT_LMM_INF) # lmm results

data = data.frame(cbind(x,y))
colnames(data) = c("GIANT","UKBiobank")

noNA = (!is.na(x))&(!is.na(y))


pdf(paste0('plots/Standing.height.GIANTcomparisonPval-LMM.imputed.chr',chrom,'.pdf'),bg="transparent",width=1500/150)

d <- ggplot(data[noNA,], aes(GIANT, UKBiobank)) + stat_binhex(bins=100) + scale_fill_gradientn(name="Marker count" ,breaks=rev(my_breaks),trans="log10",colors=viridis_pal()(10),labels = get10power2) +  scale_x_continuous( expand = c(0.05, 0.05),name=expression(-log[10](italic(p))~"in GIANT (2014)") ) +
    scale_y_continuous(expand = c(0.05, 0.05),name=expression(-log[10](italic(p))~"in UK Biobank imputed data") ) + geom_abline(slope=1, intercept=0,color="red",linetype="longdash")+ ggtitle(paste0( sum(noNA)," overlapping markers")) + myTheme
    
print(d)
dev.off()




################
#### INFO DISTRIBUTION

frac_signif = c()
frac_signif2 = c()
frac_signif3 = c()
frac_sem = c()
frac_sem2 = c()

d=0.1
info_cum_bins = seq(0,1,by=d)

for ( info in info_cum_bins){
    print(info)
#    sig = sum((DF2$INFO<=info)&(DF2$P_BOLT_LMM_INF<(5e-8)))
#belowInf = sum(DF2$INFO<=info)

    these = (DF2$INFO<=info)&(DF2$INFO>(info-d))
belowInf2 = sum(these)
sig2 = sum(these&(DF2$P_BOLT_LMM_INF<(5e-8)))

frac_signif2 = c(frac_signif2,sig2/belowInf2)
frac_sem2  = c(frac_sem2,sqrt(frac_signif2*(1-frac_signif2))/sqrt(belowInf2))


theseMAF = (DF2$INFO<=info)&(DF2$INFO>(info-d)&(DF2$MAF>0.001))
belowInf3 = sum(theseMAF)
sig3 = sum(theseMAF&(DF2$P_BOLT_LMM_INF<(5e-8)))

frac_signif3 = c(frac_signif3,sig3/belowInf3)

}

pdf(paste0("plots/",resultsIMP$Pvalset,"-infobins-by-significance.pdf"),bg="transparent")


y = -log10(DF2$P_BOLT_LMM_INF)
x = DF2$INFO
plot(x[DF2$P_BOLT_LMM_INF<(5e-8)],y[DF2$P_BOLT_LMM_INF<(5e-8)],xlab="INFO",ylab="-log10(p-value)",main="All markers, chromosome 2")
abline(h=-log10(5e-8),col="red")


plot(info_cum_bins,frac_signif2,pch=16,ylab="Fraction of markers in bin with p-value <5e-8",xlab="Info bins (right inclusive)",main="All markers, chromosome 2")
#segments(info_cum_bins,frac_signif2-frac_sem2,info_cum_bins,frac_signif2+frac_sem2,col="blue")

subset = (DF2$P_BOLT_LMM_INF<(5e-8))&(DF2$MAF>0.001)
plot(x[subset],y[subset],xlab="INFO",ylab="-log10(p-value)",main="All markers with MAF > 0.001, chromosome 2")
abline(h=-log10(5e-8),col="red")

plot(info_cum_bins,frac_signif3,pch=16,ylab="Fraction of markers in bin with p-value <5e-8",xlab="Info bins (right inclusive)",main="All markers with MAF > 0.001, chromosome 2")


dev.off()


################################################
#### CREDIBLE SET ANALYSIS
################################################

# data from plot-posteriors.R
load("/well/ukbiobank/qcoutput.V2_QCed.sample-QC/data/GWAS/otherGWAS/Standing.height/hitCounts/CredibleSetsAnalysis.QC3.RData",verbose=TRUE)
sourceNames = c("IMP"="UK Biobank (imputed data)","IMPSUB"="UK Biobank (imputed data subset)","GENO"="UK Biobank (genotyped data)","GIANT"="GIANT (2014)")

type1="GIANT"
type2="IMP"
b=0.95

# Analysis with all snps

DATA = extractCredibleData(CredibleSets_QC3_GIANTvsIMP,theseRegionsGIANT_and_IMP)

plotName = paste0("GIANT-IMP-top",nrow(theseRegionsGIANT_and_IMP),"..GIANTvsIMP")
pdf(paste0("plots/credible-sets.",plotName,".pdf"),height=10/2,width=10/2)

par(cex.axis=1.5/2,cex.main=2/2,cex.lab=2/2,mar=c(6,6,5,2),lwd=0.8)

plotCredibleSizes(DATA,type1,type2,Expand=0.5)

dev.off()



# Analysis with overlapping snps
DATA = extractCredibleData(CredibleSets_QC3_GiantImpOverlap,theseRegionsGIANT_and_IMP)

plotName = paste0("GIANT-IMP-top",nrow(theseRegionsGIANT_and_IMP),"-overlappingOnly..GIANTvsIMP")
pdf(paste0("plots/credible-sets.",plotName,".pdf"),height=10/2,width=10/2)

par(cex.axis=1.5/2,cex.main=2/2,cex.lab=2/2,mar=c(6,6,5,2),lwd=0.8)

plotCredibleSizes(DATA,type1,type2,Expand=0.5)

dev.off()




#[1] "Size-1 numbers"
#[1] 78
#[1] 85
#[1] "median size"
#[1] 6
#[1] 8
#[1] "median size per snp"
#[1] 0.04700855
#[1] 0.01038961
#[1] "total number markers"
#[1] 106263
#[1] 768502
#[1] "sizes"

#[1] 76
#[1] 123
#[1] "median size"
#[1] 6
#[1] 4
#[1] "median size per snp"
#[1] 0.04761905
#[1] 0.03921569
#[1] "total number markers"
#[1] 105421
#[1] 105421


#########################
#### IOP Manhattan plot




#################################
# COMPARISON WITH EXAC (QC-Scripts/ExacComparison)
#################################

# original exac
exac="/well/ukbiobank/qcoutput.V2_QCed.sample-QC/data/Exac/ExAC.r1.sites.vep.UKBB-SNPs.aCounts_NFE.txt"
exacMaf = read.table(exac,header=FALSE,stringsAsFactors=FALSE)

load(paste0(baseSampleQCDir,'/QC-Scripts/ExacComparison/Exac-UKBiLEVEAX_b1-b11.Batch_b001_b095-comparison.RData'),verbose=TRUE)#fisherP,zscoreP

# for some reason there are duplicates in the table. Mostly indels. They all have the same data actually
#unique(exacUKB[exacUKB$SNP2%in%exacUKB$SNP2[duplicated(exacUKB$SNP2)],])
exacUKB2 = exacUKB[!duplicated(exacUKB$SNP2),]
exacUKB = exacUKB2

###### Some snp categories

# monomorphic in both
monoBoth = (exacUKB$MAF==0)&(exacUKB$MAF_exac_align==0)

# polymorphic in both
polyBoth = (exacUKB$MAF>0)&(exacUKB$MAF_exac_align>0)

# rare
#rare = (exacUKB$MAF_exac_align<mafBins[4])&(exacUKB$MAF<mafBins[4])
#vrare = (exacUKB$MAF_exac_align<mafBins[3])&(exacUKB$MAF<mafBins[3])
#vrare2 = (exacUKB$MAF_exac_align<5*mafBins[3])&(exacUKB$MAF<(5*mafBins[3]))

rare = (exacUKB$freq_exac_align<mafBins[4])&(exacUKB$MAF<mafBins[4])
vrare = (exacUKB$freq_exac_align<mafBins[3])&(exacUKB$MAF<mafBins[3])
vrare2 = (exacUKB$freq_exac_align<5*mafBins[3])&(exacUKB$MAF<(5*mafBins[3]))

# high call rates in both exac in ukbb
missThresh = 0.9
N_exac=33370*2 # This is from the NFE population in ExAC: http://exac.broadinstitute.org/faq
incl = ( exacUKB$exac_n_count > N_exac*missThresh )&( (exacUKB$obs_chroms/exacUKB$ukb_total_chroms) > missThresh )

# low fisher p-value (not used here)
pthresh = 10^-12  # same as our other tests
lowP = fisherP < pthresh
    


####### What samples did I actually use to compute MAF? See ../ExacComparison/process-Exac-UKBB.R for criteria
# NFE = non-Finnish European.

exacSamplesFile = "../ExacComparison/ukb-autosome-HapMap3.pcs.inliers.no.fins.txt"
exacSamples = read.table(exacSamplesFile,header=FALSE,stringsAsFactors=FALSE)[,1]

# Plot the ukbiobank only PCA results for these individuals
PCs = outTable[,grepl("PC",colnames(outTable))]

eth = outTable$Ethnic.background
pop = ethnicity2pop(eth)
Colors = ethnicity2col[pop]
Chars = ethnicity2char[pop]
# fade out samples we are not using (or make them gray?)
#Colors[!outTable$PIID%in%ukbbEur]= add.alpha(Colors[!outTable$PIID%in%ukbbEur],0.3)
Colors[!outTable$PIID%in%exacSamples]= "gray"

Order = order.by.number.occurrences(Colors)

png(paste0('plots/',releaseSampleQCPrefix,'-pca-UKB-NFE-%02d.png'),width=3*1500,height=3*1500,res=450)
par(cex.lab=1.5,mar=c(5.1,5.1,3,2))

for (pc in 1:4){
    
    if(pc%%2==0) next
    #pdf(paste0('plots/',releaseSampleQCPrefix,'-pca-UKB-NFE-pc',pc,'.pdf'),width=1500/150,height=1500/150,bg="transparent")

print(paste0('Plotting PCs',pc,' and ',pc + 1))

x = PCs[[paste0("PC",pc)]]
y = PCs[[paste0("PC",pc+1)]]

plot(x[Order],y[Order],xlab=paste0('PC ',pc),ylab=paste0('PC ',pc+1),
col=Colors[Order],pch=Chars[Order])    
#axis(1,cex.lab=1.3)
#axis(2,cex.lab=1.3)
#dev.off()

}
                                        dev.off()

###### HEXBIN plots for Exac comparison

###### Hex bin colors
my.hex.colors = colorRampPalette(colors=c("darkgray","blue2"))
######

myGridParSettings = gpar(lineheight=1.3)

# All snps with cr >0.9
hex3a = hexbin(exacUKB$MAF[(incl)],exacUKB$MAF_exac_align[(incl)],xbins=100)
#png(paste0('plots/',OutputFile,'-ExacComparison-hexbin-exacMiss',missThresh,'.png'),bg="transparent",width=1500,height=1500,res=150)
pdf(paste0('plots/',releaseSampleQCPrefix,'-ExacComparison-hexbin-exacMiss',missThresh,'.pdf'),bg="transparent",width=1500/150,height=1500/150)
pushViewport(viewport(gp=myGridParSettings))
hb = plot(hex3a,main=paste0(sum((incl),na.rm=TRUE)," markers in ExAC matched to UK Biobank\nand with call rate > ",missThresh),xlab="MAF in UK Biobank",ylab="MAF in ExAC",colorcut=c(0,5^seq(0:6)/sum( 5^seq(0:6)),1),colramp=my.hex.colors,newpage=FALSE,legend=1,maxcnt=1000*ceiling(max(hex3a@count)/1000))
hexVP.abline(hb$plot,0,1, col= "red",lty=3)
dev.off()

# With the rare box
pdf(paste0('plots/',releaseSampleQCPrefix,'-ExacComparison-hexbin-exacMiss',missThresh,'-boxed.pdf'),bg="transparent",width=1500/150,height=1500/150)
pushViewport(viewport(gp=myGridParSettings))
hb = plot(hex3a,main=paste0(sum((incl),na.rm=TRUE)," markers in ExAC matched to UK Biobank\nand with call rate > ",missThresh),xlab="MAF in UK Biobank",ylab="MAF in ExAC",colorcut=c(0,5^seq(0:6)/sum( 5^seq(0:6)),1),colramp=my.hex.colors,newpage=FALSE,legend=1,maxcnt=1000*ceiling(max(hex3a@count)/1000))
hexVP.abline(hb$plot,0,1,col= "red",lty=3)
myHexbin.rect(hb$plot,0,0,mafBins[4],mafBins[4],col.line="black")
dev.off()

# As above but rare only
hex3 = hexbin(exacUKB$MAF[(rare)&(incl)],exacUKB$MAF_exac_align[(rare)&(incl)],xbins=100)
#png(paste0('plots/',releaseSampleQCPrefix,'-ExacComparison-hexbin-exacMiss',missThresh,'-zoom.png'),bg="transparent",width=1500,height=1500,res=150)
pdf(paste0('plots/',releaseSampleQCPrefix,'-ExacComparison-hexbin-exacMiss',missThresh,'-zoom.pdf'),bg="transparent",width=1500/150,height=1500/150)
pushViewport(viewport(gp=gpar(lineheight=2)))
hb = plot(hex3,main=paste0(sum((rare)&(incl),na.rm=TRUE)," rare markers"),xlab="MAF in UK Biobank",ylab="MAF in ExAC",colorcut=c(0,2^seq(0:10)/sum( 2^seq(0:10)),1),colramp=my.hex.colors,newpage=FALSE,legend=1,maxcnt=1000*ceiling(max(hex3@count)/1000))
hexVP.abline(hb$plot,0,1, col= "red",lty=3)
dev.off()



# using gplot!!
library(ggplot2)

data = data.frame(cbind(exacUKB$MAF,exacUKB$freq_exac_align))  # <=== Use freq_exac_align!
colnames(data) = c("UKBiobank","ExAC")


##########
# Lm of data
reg = lm(ExAC~UKBiobank,data=data[incl,])
# r^2 with intercept as variable = 0.9309;
# r^2 with intercept as 0 = 0.9426; estimate = 1.0032964
sumReg = summary(reg)
r2 = sumReg$r.squared


myTheme = theme_bw() + theme(aspect.ratio=1,plot.title = element_text(margin = margin(0,0,25,0),size=16,face="bold"),axis.title.x = element_text(margin = margin(20,0,0,0),size=12),axis.title.y = element_text(margin = margin(0,20,0,0)),axis.text=element_text(size=14))

my_breaks = 10^seq(0,10,1)
my_colours = viridis_pal(begin = 0.1,end = 0.98)(10)
my_abline = geom_abline(slope=1, intercept=0,color="red",linetype="longdash",size=0.3)

pdf(paste0('plots/',releaseSampleQCPrefix,'-ExacComparison-hexbin-exacMiss',missThresh,'.pdf'),bg="transparent",width=1500/150)

d <- ggplot(data[incl,], aes(UKBiobank, ExAC)) + stat_binhex(binwidth = c(0.005, 0.005)) + scale_fill_gradientn(name="Count" ,breaks=rev(my_breaks),trans="log10",colors=my_colours) +  scale_x_continuous( expand = c(0.01, 0.01),name="MAF in UK Biobank") +
    scale_y_continuous(expand = c(0.01, 0.01),name="Frequency in ExAC") + my_abline + ggtitle(paste0("Comparison with ExAC at ",sum((incl),na.rm=TRUE)," overlapping markers")) + myTheme + theme(aspect.ratio=1.5)
    
print(d)
dev.off()


pdf(paste0('plots/',releaseSampleQCPrefix,'-ExacComparison-hexbin-exacMiss',missThresh,'-zoom.pdf'),bg="transparent",width=1500/150)

d <- ggplot(data[(rare)&(incl),], aes(x=UKBiobank, y=ExAC)) + stat_binhex(binwidth = c(0.0001, 0.0001)) +  scale_fill_gradientn(name="Count" ,breaks=rev(my_breaks),trans="log10",colors=my_colours) +  scale_x_continuous( expand = c(0.0002, 0.0002),name="MAF in UK Biobank") +
  scale_y_continuous(expand = c(0.0002, 0.0002),name="Frequency in ExAC") + my_abline + ggtitle(paste0("Comparison with ExAC at ",sum((incl)&(rare),na.rm=TRUE)," overlapping rare markers")) + myTheme

print(d)
dev.off()



##########
# Cluster plots of exac 0 or ukb 0 and pass the call rate test
# NOTE: MAF is UKBiobank maf

exac0snps =  (exacUKB$MAF>0.001)&(exacUKB$MAF_exac_align==0)&incl
ukbb0snps =  (exacUKB$MAF==0)&(exacUKB$MAF_exac_align>0.001)&incl

exac1snps =  (exacUKB$freq_exac_align>0.75)&incl
exac0snps2 = (exacUKB$MAF>0.001)&(exacUKB$freq_exac_align==0)&incl
ukbb0snps2 = (exacUKB$MAF==0)&(exacUKB$freq_exac_align>0.001)&incl

# Total outside plausible range = 287 SNPs
outTotal = sum(exac0snps2) + sum(ukbb0snps2&(!exac1snps)) + sum(exac1snps)

# Total snps considered (at least 1/1000 in one study 53,397)
totalConsid = sum(( (exacUKB$MAF>0.001)|(exacUKB$freq_exac_align>0.001) )&incl )

# Total snps not considered (less than 1/1000 in both studies 37,901)
totalNotConsid = sum(( (exacUKB$MAF<=0.001)&(exacUKB$freq_exac_align<=0.001) )&incl )

# Fraction poor quality
outTotal/totalConsid
outTotal/(totalNotConsid+totalConsid)

# 0.005374834 = 



# sort by MAF
set1 = exacUKB$SNP[exac0snps][order(exacUKB$MAF[exac0snps])]
set2 = exacUKB$SNP[ukbb0snps][order(exacUKB$MAF_exac_align[ukbb0snps])]
set3 = exacUKB$SNP[exac1snps][order(exacUKB$freq_exac_align[exac1snps])]

#set.seed(1234567)
sub1 = set1#[seq(1,length(set1),4)] # select every 30th ordered by MAF (lowest at beginning)
sub2 =  set2[seq(1,length(set2),4)]
sub3 =  set3[seq(1,length(set3),2)]

exacUKB$MAF[match(set1,exacUKB$SNP)]
exacUKB$MAF_exac_align[match(set2,exacUKB$SNP)]
exacUKB$MAF_exac_align[match(set3,exacUKB$SNP)]


forSystem = paste0("Rscript /well/ukbiobank/qcoutput.V2_QCed.sample-QC/QC-Scripts/R/scripts/V2_QCed.makeClusterPlots_v2.R /well/ukbiobank/expt/V2_QCed.SNP-QC/data ",paste(sub1,collapse=",")," cluster_plots_exac0 -onepage -released -rNumber 6655 &")


forSystem = paste0("Rscript /well/ukbiobank/qcoutput.V2_QCed.sample-QC/QC-Scripts/R/scripts/V2_QCed.makeClusterPlots_v2.R /well/ukbiobank/expt/V2_QCed.SNP-QC/data ",paste(sub2,collapse=",")," cluster_plots_ukbb0 -onepage -released -rNumber 6656 &")


forSystem = paste0("Rscript /well/ukbiobank/qcoutput.V2_QCed.sample-QC/QC-Scripts/R/scripts/V2_QCed.makeClusterPlots_v2.R /well/ukbiobank/expt/V2_QCed.SNP-QC/data ",paste(sub3,collapse=",")," cluster_plots_exac1 -onepage -released -rNumber 6656 &")
forSystem = paste0("Rscript /well/ukbiobank/qcoutput.V2_QCed.sample-QC/QC-Scripts/R/scripts/V2_QCed.makeClusterPlots_v2.R /well/ukbiobank/expt/V2_QCed.SNP-QC/data ",paste(sub3,collapse=",")," cluster_plots_exac1 -onepage -rNumber 6656 &")


these1 = exacUKB[match(set1,exacUKB$SNP),]
these1= these1[order(these1$MAF,decreasing=TRUE),]
## All but one marker are multi-allelic sites in ExAC, and/or an indel in one or both. Total snps =40
## Number of alternative alleles:
#1  2  3  5 
#20 16  3  1

these2 = exacUKB[match(set2,exacUKB$SNP),]
these2= these2[order(these2$MAF_exac_align,decreasing=TRUE),]
## 40 multi-allelics in ExAC. The rest are not. No apparent excess of indels.


## Total multi-allelic sites in comparison set:
sum(exacUKB$is.multi[incl])  # 13,263

## Total multi-allelic sites in comparison set with more than 2 alternative alleles:
nalts = sapply(exacUKB$V4,function(x) length(str_split(x,",")[[1]]) )
sum(exacUKB$is.multi[(incl)&(nalts>2)])  # 977
## number of alternative alleles in all comparison set:
table(nalts[incl])
#    1     2     3     4     5     6 
#78035 12286   924    39     7     7 


these3 = exacUKB[match(set3,exacUKB$SNP),]
these3= these3[order(these3$freq_exac_align,decreasing=TRUE),]
## 76 markers; 29 are multi


exac0snpsInfo = these1
ukbb0snpsInfo = these2
exac2snpsInfo = these3

save(exac0snpsInfo,ukbb0snpsInfo,file="ExacComparison-exac0-and-ukb0-comparisonMarkers.RData")
