### This script is just like numbersForPaper.R but focussing on the White British subset PCA.

h = c("/well/ukbiobank/expt/V2_QCed.SNP-QC/src/V2_QCed.snpqc-tests.R","/well/ukbiobank/expt/V2_QCed.SNP-QC/src/V2_QCed.bin2clusterplots.R","/well/ukbiobank/qcoutput.V2_QCed.sample-QC/QC-Scripts/R/scripts/readPSperformance.R","/well/ukbiobank/qcoutput.V2_QCed.sample-QC/QC-Scripts/R/scripts/auxFunctions.R","/well/ukbiobank/qcoutput.V2_QCed.sample-QC/QC-Scripts/R/scripts/compute-Moran.R")
for(s in h) source(s)
source("/well/ukbiobank/qcoutput.V2_QCed.sample-QC/QC-Scripts/R/scripts/ukbbcolors.R")

library(igraph)
library(xtable)
library(hexbin)
library(latticeExtra)
library(viridis)


setwd('/well/ukbiobank/qcoutput.V2_QCed.sample-QC/QC-Scripts/forPaper')


# Main sample QC file for release (generated by $basedir/QC-Scripts/Sample-QC/Flags/create-sample-table.R)
###########
releaseSampleQCPrefix = 'b1__b11-b001__b095-sampleTable_v4'
###########


load(paste0('../../data/ForRelease/',releaseSampleQCPrefix,'_allColumns.RData'),verbose=TRUE)
PCsAll = PCs

#### LOAD IN THE WB PCs. Created by plot-White-British-PCA.R
load(file=paste0(baseSampleQCDir,"/data/PCA/b1__b11-b001__b095-pca-UKbio-White_British_subset.RData") ,verbose=TRUE)


#PCs = outTable[,grepl("PC",colnames(outTable))]
# Reorder outTable so it's in the same order as the PCs table.
# Some of these samples are not actually in outTable (duplicates)
dim(PCs)
PCs = PCs[PCs$PIID%in%outTable$PIID,]
dim(PCs)
outTable2 = outTable[match(PCs$PIID,outTable$PIID),]
dim(outTable2)

nPCs = sum(grepl("PC",colnames(PCs)))
print(paste0(nPCs," PCs"))

## Plot the first XX PCs by country of birth
cob =  get.place.of.birth(outTable2)
eth = ethnicity2pop(outTable2$Ethnic.background)
tab= table(cob)
cob2 = cob
minSamples=100
tooSmall = names(tab[tab<minSamples])
paste0(sum(cob%in%tooSmall)," inds in groups smaller than ",minSamples)
cob2[cob%in%c(tooSmall,"Prefer_not_to_answer","Do_not_know")] = "Other/Unknown"

print(table(cob2))
countries = table(cob2)
countryToCol = sort(countries,decreasing=T)
myCountryCols = generateColours(names(countryToCol))
myCountryCols[[1]] = myCountryCols[[1]][-length(myCountryCols[[1]])]# remove Unknown from the end of the vector
myCountryCols[[2]] = myCountryCols[[2]][-length(myCountryCols[[2]])]


myCountryColours = c(
"England" = "#2171B5" ,
"Scotland" = "#D94801",
"Wales" = "#3F007D" ,
"Northern_Ireland" =  "#00441B",
"Republic_of_Ireland" = "#C8CE46",
    "United_Kingdom" = "#9E9AC8",
    "Channel_Islands" = "#CD8500",
    "Germany" = "#FFC822",
    "Kenya" = "#339999" )

myCountryShapes = c(
    "England" = 4 ,
    "Scotland" = 0,
    "Wales" = 6,
    "Northern_Ireland" =  2,
    "Republic_of_Ireland" = 5,
    "United_Kingdom" = 3,
    "Channel_Islands" = 1,
    "Other/Unknown" = 2,
    "Malta" = 3)

myCountryCols[[1]][names(myCountryColours)] = myCountryColours
myCountryCols[[2]][names(myCountryShapes)] = myCountryShapes

myCountryOrder = names(countryToCol)
myCountryOrder = myCountryOrder[c(1:4,15,19,22,6:14,16:18,20,21,23,24,5)]

save(myCountryCols,myCountryShapes,myCountryOrder,file=paste0('plots/',releaseSampleQCPrefix,'-PCA-WhiteBritishSubset-country-colours.RData'))

load(file=paste0('plots/',releaseSampleQCPrefix,'-PCA-WhiteBritishSubset-country-colours.RData'),verbose=TRUE)

# plot the legend separately
                                        #png(paste0('plots/',releaseSampleQCPrefix,'-PCA-LEGEND.png'),bg="transparent",width=3*1500,height=3*1500,res=450)
pdf(paste0('plots/',releaseSampleQCPrefix,'-PCA-WhiteBritishSubset-LEGEND-test.pdf'),bg="transparent",width=1500/150,height=1500/150)
plot.new()
eths1 = myCountryOrder  # raw country groupings
legend("topleft",legend=paste(eths1,myCountryCols[[1]][eths1],myCountryCols[[2]][eths1])[1:20],col=myCountryCols[[1]][eths1][1:20],pch=myCountryCols[[2]][eths1][1:20],pt.lwd=2,horiz=F,bty="n",title="Country of birth")
legend("topright",legend=paste(eths1,myCountryCols[[1]][eths1],myCountryCols[[2]][eths1])[21:49],col=myCountryCols[[1]][eths1][21:49],pch=myCountryCols[[2]][eths1][21:49],pt.lwd=2,horiz=F,bty="n",title="Country of birth")
dev.off()


pdf(paste0('plots/',releaseSampleQCPrefix,'-PCA-WhiteBritishSubset-LEGEND.pdf'),bg="transparent",width=1500/150,height=1500/150)
plot.new()
eths1 = myCountryOrder  # raw country groupings
tab = table(cob2)[myCountryOrder]
legend("topleft",legend=paste0(eths1," (" ,tab,")")[1:12],col=myCountryCols[[1]][eths1][1:12],pch=myCountryCols[[2]][eths1][1:12],pt.lwd=2,horiz=F,bty="n",title="Country of birth")
legend("topright",legend=paste0(eths1," (" ,tab,")")[13:24],col=myCountryCols[[1]][eths1][13:24],pch=myCountryCols[[2]][eths1][13:24],pt.lwd=2,horiz=F,bty="n",title="Country of birth")
dev.off()

# Table of counts
#png(paste0('plots/',releaseSampleQCPrefix,'-PCA-LegendCounts.png'),bg="transparent",width=1500,height=1500,res=150)
pdf(paste0('plots/',releaseSampleQCPrefix,'-PCA-LegendCounts.pdf'),bg="transparent",width=1500/150,height=1500/150)
plot.new()
tab = sort(table(pop),decreasing=T)
eths = names(tab)
perc = 100*tab/sum(tab)
perc = c(paste0("(",round(perc,2),"%)"),NA)
legend("topleft",legend=c(tab,sum(tab)),col=c(ethnicity2col[eths],"transparent"),pch=c(ethnicity2char[eths],1),pt.lwd=2,horiz=F,bty="n")
legend("topleft",legend=perc,col="transparent",inset=c(0.08,0),pch=NA,horiz=F,bty="n")
legend("topleft",legend=paste0("\t\t",c(eths,"Total")),col="transparent",inset=c(0.08,0),pch=NA,horiz=F,bty="n")
dev.off()



#load(file=paste0("../PCA/pca-UKBio/pca-UKBio-countryColours.RData"),verbose=T)
Colors = myCountryCols[[1]][cob2]
Chars = myCountryCols[[2]][cob2]

Order = order.by.number.occurrences(cob2)
#Order = Order[sort(sample(1:length(Order),2000,replace=FALSE))]

png(paste0('plots/',releaseSampleQCPrefix,'-PCA-WhiteBritishSubset-%02d.png'),bg="transparent",width=3*1500,height=3*1500,res=450)
par(cex.lab=1.5,mar=c(5.1,5.1,3,2))
for (pc in 1:nPCs){
# for (pc in 1:3){
    
    if(pc%%2==0) next

    print(paste0('Plotting PCs',pc,' and ',pc + 1))

    x = PCs[[paste0("PC",pc)]]
    y = PCs[[paste0("PC",pc+1)]]

    plot(x[Order],y[Order],xlab=paste0('PC ',pc),ylab=paste0('PC ',pc+1),
         col=Colors[Order],pch=Chars[Order])#,axes=FALSE)    
#    axis(1,cex.lab=1.3)
#    axis(2,cex.lab=1.3)

}

dev.off()

# Plot pdf of first 6 pcs

for (pc in 1:6){
    
if(pc%%2==0) next
    print(paste0('Plotting PCs',pc,' and ',pc + 1))
pdf(paste0('plots/',releaseSampleQCPrefix,'-PCA-WhiteBritishSubset-',pc,'.pdf'),bg="transparent",width=1500/150,height=1500/150)
par(cex.lab=1.5,mar=c(5.1,5.1,3,2))

    x = PCs[[paste0("PC",pc)]]
    y = PCs[[paste0("PC",pc+1)]]

    plot(x[Order],y[Order],xlab=paste0('PC ',pc),ylab=paste0('PC ',pc+1),
         col=Colors[Order],pch=Chars[Order],axes=FALSE)    
#    axis(1,cex.lab=1.3)
#    axis(2,cex.lab=1.3)

dev.off()
}


## Plot all pairs of first 6 pcs in a grid
#Order=sample(Order,1000,replace=FALSE)
printPCs = 6

png(paste0('plots/',releaseSampleQCPrefix,'-PCA-WhiteBritishSubset-grid-allpairs',printPCs,'-%02d.png'),bg="transparent",width=3*1500,height=3*1500,res=450)

    plot.grid.PCs(as.data.frame(PCs[Order,grepl("PC",colnames(PCs))]),n=6,maxPC=printPCs,shapes=Chars[Order],colours=Colors[Order],cex.axis=0.5)

dev.off()

#remove odd-numbered pages!
sapply(seq(1,nPCs,by=2),function(i) system(paste0("rm plots/",releaseSampleQCPrefix,'-PCA-grid-allpairs',printPCs,'-0',i,'.png')))


## Plot using a grid

printPCs = 6

png(paste0('plots/',releaseSampleQCPrefix,'-PCA-WhiteBritishSubset-grid-%02d.png'),bg="transparent",width=1500,height=1500,res=150)
# if number of PCs is less than 10, and also uneven...
if(printPCs <= 10) {
    
    plot.grid.PCs(as.data.frame(PCs[Order,grepl("PC",colnames(PCs))]),n=6,shapes=Chars[Order],colours=Colors[Order])
 
} else {
    sequence = seq(1,nPCs,10)

    for(l in sequence){
        print(l)
        plot.grid.PCs(as.data.frame(PCs[Order,paste0("PC",c(l:(l+min(9,(nPCs-l)) )))]),shapes=Chars[Order],colours=Colors[Order])
    }
}
dev.off()

#remove odd-numbered pages!
sapply(seq(1,nPCs,by=2),function(i) system(paste0("rm plots/",releaseSampleQCPrefix,'-PCA-grid-0',i,'.png')))


#### Plot the eigen values (see pipeline.sh)
fastPCAout = paste0(baseSampleQCDir,"/data/PCA/b1__b11-b001__b095-autosome-sampleqc-fastpca-highquality-White_British.evecs")

evalues = t(read.table(fastPCAout,header=FALSE,nrow=1,comment.char="%")[,-1])[,1]

# sum(evalues)
# 6781.928

pdf(paste0('plots/',releaseSampleQCPrefix,'-PCA-WhiteBritishSubset-EigenValues.pdf'),bg="transparent",width=1800/150,height=1500/150)
barplot(evalues,xlab="PC",ylab="Eigenvalue",col="gray35",border="lightgray",names.arg=1:40)
dev.off()

pdf(paste0('plots/',releaseSampleQCPrefix,'-PCA-WhiteBritishSubset-EigenValues-fractions.pdf'),bg="transparent",width=1800/150,height=1500/150)
b=barplot(evalues/sum(evalues),xlab="PC",ylab="Fraction of sum of all 40 eigenvalues",col="gray35",border="lightgray",names.arg=1:40,main="Eigenvalues for 40 PCs as a fraction of total",ylim=c(0,0.15),yaxt="n")
axis(2,las=2)
text(x=b[1],y=evalues[1]/sum(evalues)+0.004,labels=round(evalues[1],0),xpd=NA)
text(x=b[40],y=evalues[40]/sum(evalues)+0.004,labels=round(evalues[40],0),xpd=NA)
text(x =(b[21]+b[20])/2,y=0.15,labels="Absolute values for PCs 1 and 40 are shown above bars",xpd=NA)
dev.off()

# make a text file
evalText = cbind(1:40,evalues)
colnames(evalText) = c("PC","Eigenvalue (fastPCA)")

write.table(evalText,file=paste0(releaseSampleQCPrefix,'-PCA-WhiteBritishSubset-EigenValues.txt'),row.names=FALSE,col.names=TRUE,quote=FALSE,sep="\t")

xTab = xtable(evalText, caption = NULL, label = NULL, align = NULL, display = NULL)
sink(file=paste0(releaseSampleQCPrefix,"-PCA-WhiteBritishSubset-EigenValues.tex"))
print(xTab,size="small",sanitize.colnames.function = white,include.rownames = FALSE)

sink()


####### Plot on a map!





# get mapping shape files etc.
load(mapFileUK0,verbose=TRUE)
uk0 = british_isles_sp_map_bng
uk0@bbox = rbind(c(-210500,665695),c(-10000,1235640))
# original coordinates
#          min       max
#x -296677.815  655695.6
#y    5408.466 1295640.3

baseMap = spplot(uk0,zcol="ID_0",col.regions="transparent",colorkey=FALSE,main="hello")

png("plots/test.png",height=1500,width=1000,res=150)
print(baseMap)
dev.off()

country.centres <- t(sapply(uk0@polygons,FUN=slot,name="labpt"))
colnames(country.centres) <- c("X","Y")
rownames(country.centres) <- uk0@data[,"ISO"]

###############
# Get BNG coordinates
x = outTable2$Place.of.birth.in.UK...east.co.ordinate
y = outTable2$Place.of.birth.in.UK...north.co.ordinate

# anyone with -1 is missing.
x[x==-1] = NA
y[y==-1] = NA

 # anyone in the sea is a bit dodgy .Turns out they're all from the pilot assessment centre. (see below)
# 281 individuals apparently in the sea. They were all in the stockport_pilot.
inTheSea = which((x<80000)&(y<(90000)))
x[inTheSea] = NA
y[inTheSea] = NA

sum((!is.na(x))&(!is.na(y)))
# 394603 samples!

###############
# Randomly geocode people born in Northern Ireland, and the Republic of Ireland.
NorthernIreland = which(cob2=="Northern_Ireland")

# Find northern Ireland polygon in GBR set
# NI = which(sapply(myMap@polygons[[1]]@Polygons,function(i) gContains(SpatialPolygons(Srl = list(Polygons(list(i),ID=1)),proj4string = CRS(proj4string(myMap))),
#                                                          SpatialPoints(coords = cbind(#98518,542448),proj4string = CRS(proj4string(myMap))))))
NIpolyRaw = uk0@polygons[[1]]@Polygons[214][[1]]
NIpoly = SpatialPolygons(list(Polygons(list(NIpolyRaw),ID="NI")),proj4string=CRS(proj4string(uk0)))
bb = bbox(NIpoly)
jitx=runif(5000,bb[1,1],bb[1,2])
jity=runif(5000,bb[2,1],bb[2,2])
pts=SpatialPoints(coords=cbind(jitx,jity),proj4string=CRS(proj4string((uk0))))
test=sp::over(pts,NIpoly)
good=which(!is.na(test))

length(good)>length(NorthernIreland)

# set their coordinates
x[NorthernIreland] = pts@coords[good[1:length(NorthernIreland)],1]
y[NorthernIreland] = pts@coords[good[1:length(NorthernIreland)],2]

sum((!is.na(x))&(!is.na(y)))

###############
# Randomly geocode people born in Northern Ireland, and the Republic of Ireland.
RepubIreland = which(cob2=="Republic_of_Ireland")

# Find northern Ireland polygon in GBR set
# NI = which(sapply(myMap@polygons[[1]]@Polygons,function(i) gContains(SpatialPolygons(Srl = list(Polygons(list(i),ID=1)),proj4string = CRS(proj4string(myMap))),
#                                                          SpatialPoints(coords = cbind(#98518,542448),proj4string = CRS(proj4string(myMap))))))
NIpoly2 = uk0[which(uk0@data[,"ISO"]=="IRL"),]
bb=bbox(NIpoly2)

bbPoly = SpatialPolygons(list(Polygons(list(Polygon(bb)),ID="bb")),proj4string=CRS(proj4string(uk0)))

    jitx=runif(5000,bb[1,1],bb[1,2])
    jity=runif(5000,bb[2,1],bb[2,2])
    pts=SpatialPoints(coords=cbind(jitx,jity),proj4string=CRS(proj4string((uk0))))
    test=sp::over(pts,NIpoly2)
    good=which(!is.na(test))

length(good)>length(NorthernIreland)

# set their coordinates
x[RepubIreland] = pts@coords[good[1:length(RepubIreland)],1]
y[RepubIreland] = pts@coords[good[1:length(RepubIreland)],2]

sum((!is.na(x))&(!is.na(y)))

notNA = (!is.na(x))&(!is.na(y))


colors = magma(10)
mapHeight = 0.93
mapViewPort = viewport(y=1,height=mapHeight,width=1,just="top")
histViewPort = viewport(y=0,height=(1-mapHeight),width=0.8,just="bottom")


for(i in 1:10){
    print(i)
    png(paste0('plots/',releaseSampleQCPrefix,'-POB-UK-WhiteBritishSubset-pc',i,'.png'),height=3*1500,width=3*1000,res=450,bg="transparent")
    pc = paste0("PC",i)
    cols = colour.scale(PCs[[pc]],colourSet = colors)
    Points = make.points(x[notNA],y[notNA],col=cols[notNA],pch=16,cex=0.5)
    map = update(baseMap,col.regions="lightgray",sp.layout=list(Points),main=paste("PC",i))
    plot.new()
    grid.newpage()
    pushViewport(mapViewPort)
    print(map,newpage=F)
#    grid.rect()
    upViewport(1)
    pushViewport(histViewPort)
#    grid.rect()
    par(new=T,fig=gridFIG())
    makeScaleWithHist(PCs[[pc]][notNA],colourSet = colors)
    dev.off()
}


# get spatial grid

coords = cbind(x,y)
notNA = (!is.na(rowSums(coords[,1:2]))) & (!is.na(PCs[["PC1"]]))
myExtent = rbind(range(coords[notNA,1]),range(coords[notNA,2]))

##############
cellSize = 10000  # <==== Used this in chapter!
#cellSize = 5000  # <==== Leave running overnight.
##############

############## FOR TESTING!!!!
#cellSize = 50000
##############

mySpatialGrid = getSpatialGrid(myMap=uk0,cellSize,extent=myExtent)

# grid aggregations (this is a slow bit, generally)
Aggs = list()
for(i in 1:nPCs){
    
    pc = paste0("PC",i)
    print(pc)
    
    values = PCs[[pc]]
    Aggs[[pc]] = gridMeans(coords[notNA,],values[notNA],mySpatialGrid)
}
assign(paste0("Aggs.",cellSize/1000),Aggs)

# This is moran with the nNeighbours indicators as weights
aggDummy = get(paste0("Aggs.",cellSize/1000))[[1]]
Notinthesea = which(!is.na(over(aggDummy,uk0)[,1]))
NotintheseaOrNA = intersect(Notinthesea,which(!is.na(aggDummy@data[,1])))


### THIS IS CRUCIAL, and can take many forms
for( k in c(4,20,36)){
    print(k)
    myWeightsMatrix = getWeights(myMap=uk0,mySpatialGrid,NotintheseaOrNA,method="nearestNeighbours",nNeighbours=k)
    assign(paste0("myWeightsMatrix",k),myWeightsMatrix)
}
    
#myWeightsMatrixSD3.5 = getWeights(myMap=uk0,mySpatialGrid,NotintheseaOrNA,method="Gaussian",sdGaussian=3.5)
##################

#save(cellSize,myWeightsMatrix4,myWeightsMatrix20,myWeightsMatrix36,uk0,mySpatialGrid,NotintheseaOrNA,list=c(paste0("Aggs.",cellSize/1000)),file=paste0("PCA-POB-WhiteBritishSubset-GridStats-",cellSize/1000,"KmCells.RData"))

load(file=paste0("PCA-POB-WhiteBritishSubset-GridStats-",cellSize/1000,"KmCells.RData"),verbose=TRUE)

################################ BELOW HERE DONE IN OTHER SCRIPTS
#### Compute Moran statistics under different weighting schemes

## GAUSSIAN (3.5)
moranOut1 = list()
for(i in 1:nPCs){
    
    pc = paste0("PC",i)
    print(pc)
    
    values = PCs[[pc]]
    Agg = get(paste0("Aggs.",cellSize/1000))[[pc]]
        
    thisMoran = myMoran(myMap=uk0,values,coords,mySpatialGrid,agg=Agg,cellSize=cellSize,colors=magma(10),baseMap,weightsList=myWeightsMatrixSD3.5)
    
    moranOut1[[pc]] = thisMoran
}
assign(paste0("MoranOut1.",cellSize/1000),moranOut1)

#save(list=paste0("MoranOut1.",cellSize/1000)),file=paste0("PCA-POB-WhiteBritishSubset-MoranResults-",cellSize/1000,"KmCells-3.5Gaussian.RData"))

## 20 nearest neighbours
moranOut2 = list()
for(i in 1:nPCs){
    
    pc = paste0("PC",i)
    print(pc)
    
    values = PCs[[pc]]
    Agg = get(paste0("Aggs.",cellSize/1000))[[pc]]
        
    thisMoran = myMoran(myMap=uk0,values,coords,mySpatialGrid,agg=Agg,cellSize=cellSize,colors=magma(10),baseMap,weightsList=myWeightsMatrix20)
    
    moranOut2[[pc]] = thisMoran
}
assign(paste0("MoranOut2.",cellSize/1000),moranOut2)

#save(list=paste0("MoranOut2.",cellSize/1000),file=paste0("PCA-POB-WhiteBritishSubset-MoranResults-",cellSize/1000,"KmCells-20Neighbours.RData"))


## 20 nearest neighbours --- Find null using a permutation test!
moranOut2.null = list()
set.seed(7293858)

for(i in 1:nPCs){
#for(i in 1:3){
    
    pc = paste0("PC",i)
    print(pc)
    
    values = PCs[[pc]]
    Agg = get(paste0("Aggs.",cellSize/1000))[[pc]]
    Notinthesea = which(!is.na(over(Agg,uk0)[,1]))
    NotintheseaOrNA = intersect(Notinthesea,which(!is.na(Agg@data[,1])))
    N = sum(notNA)
    print(date())
    
    perm = sapply(1:200,function(x){
        #print(x)
         # permute the values (each permutation run takes about 32seconds ==> 106 mins per PC if we do 200 repeats. Best parallelise this, or run over night.)
        if(x%%10==0) print(x)
        newAgg = gridMeans(coords[notNA,],values[notNA][sample(1:N,size=N,replace=FALSE)],mySpatialGrid)
        myValues = newAgg@data$values[NotintheseaOrNA]
        out = moran.test(myValues,myWeightsMatrix20)
        return( c(out$statistic,out$estimate,out$p.value) )
    })
    print(date())

    moranOut2.null[[pc]] = perm
}

assign(paste0("moranOut2.null.",cellSize/1000),moranOut2.null)

save(list=c(paste0("moranOut2.null.",cellSize/1000),paste0("MoranOut2.",cellSize/1000)),file=paste0("PCA-POB-WhiteBritishSubset-MoranResults-",cellSize/1000,"KmCells-20Neighbours.RData"))



sapply(moranOut,function(x) x[[2]]$p.value)    # using 1/distance as the weights
sapply(moranOut1,function(x) x[[2]]$p.value)   # cellSize = 10000, and using Gaussian 3.5 as weights
sapply(moranOut2,function(x) x[[2]]$p.value)   # cellSize = 10000, and using 20 nearest neighbours as the weights (this is much faster, as numerator is a sum over 8 things!)
sapply(moranOut3,function(x) x[[2]]$p.value)   # cellSize = 10000, and using Gaussian 3.5 as weights, but proportional to the amount of data contributing to the point (i.e n per cell)

################################ ABOVE HERE DONE IN THE PARALLEL SCRIPTS BELOW


#########################
# Run all of the above in parallel!
#########################
# pc;cellsize;nreps
cellSize = 10000

for(k in c(4,20,36)){
 # submit these to the cluster
headerScript = paste0("#!/bin/bash
#$ -N submit-moran-",cellSize/1000,"Km-",k,"neibrs
#$ -o Logs
#$ -j y
#$ -cwd
#$ -V
#$ -t 1-40
Rscript /well/ukbiobank/qcoutput.V2_QCed.sample-QC/QC-Scripts/PCA/pca-UKBio/run-Moran-Null.R $SGE_TASK_ID ",cellSize," 200 ",k,"\n")

write.table(headerScript,file=paste0("/well/ukbiobank/qcoutput.V2_QCed.sample-QC/QC-Scripts/PCA/pca-UKBio/submit-moran-k",k,"neibrs.sh"),quote=FALSE,col.names=FALSE,row.names=FALSE)

}

# qsub -P donnelly.prjc -q short.qc /well/ukbiobank/qcoutput.V2_QCed.sample-QC/QC-Scripts/PCA/pca-UKBio/submit-moran.sh
qsub -P donnelly.prjc -q short.qc /well/ukbiobank/qcoutput.V2_QCed.sample-QC/QC-Scripts/PCA/pca-UKBio/submit-moran-k4neibrs.sh
qsub -P donnelly.prjc -q short.qc /well/ukbiobank/qcoutput.V2_QCed.sample-QC/QC-Scripts/PCA/pca-UKBio/submit-moran-k20neibrs.sh
qsub -P donnelly.prjc -q short.qc /well/ukbiobank/qcoutput.V2_QCed.sample-QC/QC-Scripts/PCA/pca-UKBio/submit-moran-k36neibrs.sh

# tail Logs/submit-moran-10Km.o5039291.1


##### Load in the results
load(file=paste0("PCA-POB-WhiteBritishSubset-GridStats-",cellSize/1000,"KmCells.RData"),verbose=TRUE)

myResults=list()
for(k in c(4,20,36)){
    print(k)
    moranOut2=list()
    moranOut2.null = list()

    for(i in 1:nPCs){

        load(paste0("PCA-POB-WhiteBritishSubset-MoranResults-",cellSize/1000,"KmCells-",k,"Neighbours-pc",i,".RData"),verbose=TRUE)

        null = get(paste0("moranOut2.null.",cellSize/1000,".pc",i))
        stat = get(paste0("moranOut2.",cellSize/1000,".pc",i))
        moranOut2.null[[pc]]=null
        moranOut2[[pc]]=stat
        
    }
    myResults[[as.character(k)]] = list(moranOut2,moranOut2.null)
}


###### Plot how permutation statistics changes with K

pvalByK = sapply(myResults,function(x){
    f = c()
    for(i in 1:nPCs){

        pc=paste0("PC",i)
        null =x[[2]][[pc]]
        stats = x[[1]][[pc]]$moranResults
        stat = stats$estimate[1]
        myNull = null["Moran I statistic",]
        fracOver = sum(myNull>stat)/(1+length(myNull))
        f = c(f,fracOver)
    }
    return(f)
})

pdf(paste0('plots/',releaseSampleQCPrefix,'-POB-UK-WhiteBritishSubset-aggregate-',cellSize/1000,'KmGrid-compare-neighbours-pval.pdf'),bg="transparent",width=10,height=5)

plot(1:nrow(pvalByK),pvalByK[,"20"],ylim=c(0,0.2),col=NA,xaxt="n",pch=16,ylab="Fraction of permutations with larger Moran's I statistic",xlab="PC",main="")
axis(1,at=1:nrow(pvalByK))
abline(v=1:nrow(pvalByK),col="black",lwd=0.5)

points(1:nrow(pvalByK),pvalByK[,"36"],col="blue",pch=16,cex=1.5)
points((1:nrow(pvalByK))[pvalByK[,"36"]>0.2],rep(0.2,sum(pvalByK[,"36"]>0.2)),col="blue",pch=18,xpd=NA,cex=1.5)

points(1:nrow(pvalByK),pvalByK[,"20"],col="red",pch=16,cex=1.15)
points((1:nrow(pvalByK))[pvalByK[,"20"]>0.2],rep(0.2,sum(pvalByK[,"20"]>0.2)),col="red",pch=18,xpd=NA,cex=1)

points(1:nrow(pvalByK),pvalByK[,"4"],col="purple",pch=16,cex=0.8)
points((1:nrow(pvalByK))[pvalByK[,"4"]>0.2],rep(0.2,sum(pvalByK[,"4"]>0.2)),col="purple",pch=18,xpd=NA,cex=0.5)

legend(x=15,y=0.23,horiz=TRUE,legend=c("k=4","k=20","k=36"),bty="n",pch=16,pt.cex=c(0.5,1,1.5),col=c("purple","red","blue"),xpd=NA,x.intersp=0.5)
dev.off()

#plot
pdf(paste0('plots/',releaseSampleQCPrefix,'-POB-UK-WhiteBritishSubset-aggregate-',cellSize/1000,'KmGrid-compare-neighbours-pval-bars.pdf'),bg="transparent")
barplot(t(pvalByK),beside=TRUE)
dev.off()


###### Plot the permutation statistics (based on k=20)
k=20
    
pdf(paste0('plots/',releaseSampleQCPrefix,'-POB-UK-WhiteBritishSubset-aggregate-',cellSize/1000,'KmGrid-',k,'neighbours-null.pdf'),bg="transparent")

allNull = as.vector(unlist(sapply(moranOut2.null,function(x) x["Moran I statistic",])))
h = hist(allNull,col="gray35",breaks=100,xlab="Moran's I statistic (all PCs)",main="All PCs")

for(i in 1:nPCs){
    pc=paste0("PC",i)
    null = moranOut2.null[[pc]]
    stats = moranOut2[[pc]]$moranResults
    stat = stats$estimate[1]
    myNull = null["Moran I statistic",]
    fracOver = sum(myNull>stat)/(1+length(myNull))
    mapTitle = get10power(stats$p.value,digits=4,extra =  paste0(pc,", Moran's I p-value "))
    Range = range(c(myNull,stat))
    h = hist(myNull,col="gray35",breaks=seq(Range[1],Range[2]+0.002,by=0.002),xlab="Moran's I statistic",
         xlim=Range,main=mapTitle)
    abline(v=stat,col="red",lwd=2)
    text(x=stat,y=1.07*max(h$counts),cex=1.5,xpd=NA,labels=round(fracOver,3))    
}

dev.off()


###### plot on maps
dat = uk0@data[1,]; rownames(dat) = NIpoly@polygons[[1]]@ID
NIpolyThisPC = SpatialPolygonsDataFrame(NIpoly,data=dat)
dat = uk0@data[1,]; rownames(dat) = NIpoly2@polygons[[1]]@ID
IRpolyThisPC = SpatialPolygonsDataFrame(NIpoly2,data=dat)


mapViewPort = viewport(y=1,height=1,width=1,just="top")
histViewPort = viewport(y=0.902,x=0.033,width=0.25,height=0.16,just=c("left","top"))



for(i in 1:40){
    print(i)
    pc = paste0("PC",i)
    print(pc)

    # Get values for Ireland.
    NIpolyThisPC@data$values = mean(PCs[[pc]][NorthernIreland],na.rm=TRUE)
    IRpolyThisPC@data$values = mean(PCs[[pc]][RepubIreland],na.rm=TRUE)

    # Make a grid map
    Agg = get(paste0("Aggs.",cellSize/1000))[[pc]]
    myValues = c( Agg@data$values[NotintheseaOrNA], IRpolyThisPC@data$values, NIpolyThisPC@data$values)        
    fixedLims = range(myValues)
    colorCuts =  seq(fixedLims[1],fixedLims[2],length.out=200)
    colorVector = colour.scale(colorCuts,colourSet=colors,nBreaks=200,fixedLims=fixedLims)

    irelandMap = spplot(NIpolyThisPC,zcol="values",col.regions=colorVector,cuts=200,at=colorCuts,col="transparent",lwd=0) + spplot(IRpolyThisPC,zcol="values",col.regions=colorVector,cuts=200,at=colorCuts,col="transparent",lwd=0)

    ukMap =  spplot(Agg[NotintheseaOrNA,],zcol="values",col.regions=colorVector,cuts=200,at=colorCuts)
        
    # Get moran results
    result = myMoranStats[[pc]]$moranResults
    
    mapTitle = get10power(result$p.value,digits=4,extra =  paste0(pc,", Moran's I p-value "))

    colourKeyBaseMap = spplot(uk0,zcol="ISO",col.regions=colorVector,cuts=200,at=colorCuts,col="transparent",main=pc)
        
    mainMap = colourKeyBaseMap + update(baseMap,col.regions="darkgray",col="transparent") + irelandMap + ukMap + update(baseMap,col.regions="transparent",col="black",lwd=0.5)

   
    png(paste0('plots/',releaseSampleQCPrefix,'-POB-UK-WhiteBritishSubset-pc',i,'-aggregate-',cellSize/1000,'KmGrid-20neighbours.png'),height=3*1500,width=3*1000,res=450,bg="transparent")
    plot.new()
    grid.newpage()
    pushViewport(mapViewPort)
    print(mainMap,newpage=F)
    #grid.rect()
    upViewport(1)
    pushViewport(histViewPort)
    grid.rect(gp = gpar(fill="lightgray",col="lightgray"))
    par(new=T,fig=gridFIG(),cex=0.5,mgp=c(1.5,0.5,0),mar=c(3,3,2,1),lwd=0.5)    
    null = moranOut2.null[[pc]]
    stats = moranOut2[[pc]]$moranResults
    stat = stats$estimate[1]
    myNull = null["Moran I statistic",]
    fracOver = sum(myNull>=stat)/(1+length(myNull))
    
    Range = range(c(myNull,stat))
    h = hist(myNull,col="gray35",breaks=seq(Range[1],Range[2]+0.002,by=0.002),xlab="Moran's I statistic",
         xlim=Range,main="",)
    abline(v=stat,col="red",lwd=1.5)
    text(x=stat,y=1.13*max(h$counts),cex=1.5,xpd=NA,labels=round(fracOver,3))    

    dev.off()
    
}


##############
# Try different weights matrices (use PC 1)
##############

cellSize = 10000
load(file=paste0("PCA-POB-WhiteBritishSubset-GridStats-",cellSize/1000,"KmCells.RData"),verbose=TRUE)

myKs = 5:30
myTestK = list()
for( i in 1:nPCs ){
    pc = paste0("PC",i)
    print(pc)

    Agg = Aggs.10[[pc]]
    myValues = Agg@data$values[NotintheseaOrNA]
    testK = sapply( myKs,function(k){
        
        myWeightsMatrixK = getWeights(myMap=uk0,mySpatialGrid,NotintheseaOrNA,method="nearestNeighbours",nNeighbours=k)

        out = moran.test(myValues,myWeightsMatrixK)    
        
    })
    myTestK[[pc]] = testK
}

pdf(paste0('plots/',releaseSampleQCPrefix,'-POB-UK-WhiteBritishSubset-pc',i,'-aggregate-',cellSize/1000,'KmGrid-neighboursTest.pdf'),bg="transparent",height=9*(5/4),width=10)
par(mfrow=c(5,4),mgp=c(1.5,0.5,0),mar=c(3,3,2,3),cex.axis=0.7,oma=c(2,2,2,2) )
for( i in 1:nPCs ){
    
    pc = paste0("PC",i)
    print(pc)
    testK = myTestK[[pc]]
    moransI = apply(testK,2,function(x) x$estimate[1])
    null = moranOut2.null[[pc]]
    stats = moranOut2[[pc]]$moranResults
    stat = stats$estimate[1]
    myNull = null["Moran I statistic",]
    
    Range = range(c(myNull,moransI))
    
#    if(i>16) par(mfrow=c(5,4))

    h = hist(myNull,col="gray35",border=NA,breaks=seq(Range[1],Range[2]+0.002,by=0.002),xlab=NA,
        xlim=Range,main=pc,ylab=NA)#
    abline(v=stat,col="red",lwd=1.5)
    points(moransI,par()$usr[4]*myKs/max(myKs),pch=16,col="black",xpd=NA,cex=0.8)
    axis(4,at=par()$usr[4]*myKs/max(myKs),labels=myKs,ylab="K-nearest neighbours",xpd=NA)
    points(stat,par()$usr[4]*20/max(myKs),add=TRUE,pch=16,col="red",xpd=NA,cex=0.8)
    mtext(text= "K-nearest neighbours",side = 4, outer=TRUE)
    mtext(text= "Moran's I statistic",side = 1, outer=TRUE)
    mtext(text= "Frequency",side = 2, outer=TRUE)

}
dev.off()



#########################
# What's going on with the people in the left-hand corner? Maybe they were born at sea?
#########################

#bb =  rbind(c(-100500,80000),c(0,90000))
#bbPoly = makeBboxPolygon(uk_small,bb)


inTheSea = which((x<80000)&(y<(90000)))
# 281 individuals apparently in the sea. They were all in the stockport_pilot.
myCoords = cbind(x[inTheSea],y[inTheSea])

head(outTable2[inTheSea,c(35:38,43,44,45,46)])

h = outTable2$PIID[inTheSea]
h2 = outTable2$PIID[outTable2[c(35)]=="Stockport_(Pilot)"]
h3 =  outTable2$PIID[notNA] # has a coordinate

sum(intersect(h3,h2)%in%h) # all the inTheSea individuals are in the stockport pilot.


#########################
# Compute the Moran's i statistic
#########################







    
#########################
# Plot maf distribution 
#########################
    
    # cd /well/ukbiobank/qcoutput.V2_QCed.sample-QC/QC-Scripts/PCA/pca-UKBio
    #$plink --bfile /well/ukbiobank/qcoutput.V2_QCed.sample-QC/data/PCA/b1__b11-b001__b095-autosome-sampleqc-fastpca-White_British-highquality-pruned --freq --out plink1
    #$plink --bfile /well/ukbiobank/qcoutput.V2_QCed.sample-QC/data/PCA/b1__b11-b001__b095-autosome-sampleqc-fastpca-White_British_rare-highquality-pruned --freq --out plink
    
    # maf filter 0.01
    p1 = read.table("/well/ukbiobank/qcoutput.V2_QCed.sample-QC/QC-Scripts/PCA/pca-UKBio/plink1.frq",header=TRUE)

    # maf filter 0.001
    p2 = read.table("/well/ukbiobank/qcoutput.V2_QCed.sample-QC/QC-Scripts/PCA/pca-UKBio/plink.frq",header=TRUE)

    Breaks=seq(0,0.5,by=0.01)

    pdf(paste0('plots/',releaseSampleQCPrefix,'-PCA-WhiteBritishSubset-MAF-0.01vs0.001.pdf'),bg="transparent")
    par(lwd=0.5)
    hist(p1$MAF,xlab="MAF",ylab="Number of markers (1000s)",main=paste0("Markers for PCA using filter MAF > 0.01\n",nrow(p1)," markers"),breaks=Breaks,col="gray35",border="lightgray",cex=2,xlim=c(0,0.5),yaxt="n")
    axis(2,at=seq(0,27000,by=2000),labels=seq(0,27000,by=2000)/1000,las=2)
    
    hist(p2$MAF,xlab="MAF",ylab="Number of markers (1000s)",main=paste0("Markers for PCA using filter MAF > 0.001\n",nrow(p2)," markers"),breaks=Breaks,col="gray35",border="lightgray",cex=2,xlim=c(0,0.5),yaxt="n")
    axis(2,at=seq(0,27000,by=2000),labels=seq(0,27000,by=2000)/1000,las=2)
    
    dev.off()
